\PassOptionsToPackage{prologue,dvipsnames}{xcolor}

% \usepackage{jfp-natbib-hack}
\documentclass{jfp}
\allowdisplaybreaks

\input{../prelude.tex}


\newcommand{\ottDir}{../ott/_gen}
\newcommand{\genDir}{../paper/_gen}
\newcommand{\proofGenDir}{../proofs/_gen}
\input{\ottDir/defs.tex}
\input{\ottDir/renew-ott.tex}


\setlist{topsep=0pt, itemsep=1pt}
% \setlist{nosep}
\usepackage{etoolbox}
\usepackage{parskip}
% \AtBeginEnvironment{ottdefnblock}{\setlength{\abovedisplayskip}{0pt}}
% \AtBeginEnvironment{ottdefnblock}{\setlength{\belowdisplayskip}{0pt}}
\AtBeginEnvironment{ottdefnblock}{\setlength{\abovedisplayshortskip}{0pt}}
\AtBeginEnvironment{ottdefnblock}{\setlength{\belowdisplayshortskip}{0pt}}

\setlength{\parskip}{5pt}


\renewcommand{\cite}{\citep}


% \renewcommand{\paragraph}[1]{\paragraph{#1~}}


% \usepackage{../bibliography}

% \renewcommand{\paragraph}[1]{
%   \textit{#1.} 
% }

\bibliographystyle{jfplike}

\begin{document}

\journaltitle{JFP}
\cpr{Cambridge University Press}
\doival{10.1017/xxxxx}

\lefttitle{Local Type Inference for Polarised System F with Existentials}
\righttitle{Journal of Functional Programming}

\totalpg{\pageref{lastpage01}}
\jnlDoiYr{2024}

% \title{Journal of Functional Programming: \LaTeX\ Guidelines for~authors}
\title{Local Type Inference for Polarised System F with Existentials}

\begin{authgrp}


\author{Ilya Kaysin}
% \orcid{0000-0002-6301-152X}
\affiliation{
  University of Cambridge\\
  (\email{\elink{ik404@cam.ac.uk}})
}

\author{Neel Krishnaswami}
% \orcid{0000-0003-2838-5865}
\affiliation{University of Cambridge\\(\email{\elink{nk480@cl.cam.ac.uk}})}

\end{authgrp}

% \renewcommand{\shortauthors}{Kaysin et al.}

\begin{abstract}
    We study type inference for the calculus \fexists, which is a version of
    \CBPV extended with support for fully impredicative existential and universal 
    quantifiers. We give a local type inference algorithm for this calculus
    as well as a declarative type system acting as a specification for the algorithm
    and show that the algorithm is sound and complete with respect to the declarative
    specification. The inclusion of existential quantifiers is unusual and supporting it
    required us to use a number of novel techniques including the
    combination of unification and anti-unification as part of the inference algorithm.
\end{abstract}



%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
%   <ccs2012>
%      <concept>
%          <concept_id>10003752.10003790.10011740</concept_id>
%          <concept_desc>Theory of computation~Type theory</concept_desc>
%          <concept_significance>500</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
%          <concept_desc>Software and its engineering~Functional languages</concept_desc>
%          <concept_significance>300</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10011007.10011006.10011008.10011024.10011025</concept_id>
%          <concept_desc>Software and its engineering~Polymorphism</concept_desc>
%          <concept_significance>500</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10011007.10011006.10011008.10011009.10011015</concept_id>
%          <concept_desc>Software and its engineering~Constraint and logic languages</concept_desc>
%          <concept_significance>100</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10011007.10011006.10011008.10011009.10011011</concept_id>
%          <concept_desc>Software and its engineering~Object oriented languages</concept_desc>
%          <concept_significance>100</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10011007.10011006.10011008.10011024.10011032</concept_id>
%          <concept_desc>Software and its engineering~Constraints</concept_desc>
%          <concept_significance>300</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10011007.10011006.10011008.10011024.10011031</concept_id>
%          <concept_desc>Software and its engineering~Modules / packages</concept_desc>
%          <concept_significance>300</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10011007.10011006.10011039.10011311</concept_id>
%          <concept_desc>Software and its engineering~Semantics</concept_desc>
%          <concept_significance>300</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10003752.10003753.10003754.10003733</concept_id>
%          <concept_desc>Theory of computation~Lambda calculus</concept_desc>
%          <concept_significance>500</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10003752.10003766.10003767</concept_id>
%          <concept_desc>Theory of computation~Formalisms</concept_desc>
%          <concept_significance>500</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10003752.10003809.10010031.10010032</concept_id>
%          <concept_desc>Theory of computation~Pattern matching</concept_desc>
%          <concept_significance>300</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10003752.10010124.10010125.10010130</concept_id>
%          <concept_desc>Theory of computation~Type structures</concept_desc>
%          <concept_significance>500</concept_significance>
%          </concept>
%      <concept>
%          <concept_id>10003752.10010070.10010071.10010078</concept_id>
%          <concept_desc>Theory of computation~Inductive inference</concept_desc>
%          <concept_significance>500</concept_significance>
%          </concept>
%    </ccs2012>
%   \end{CCSXML}
  
  % \ccsdesc[500]{Theory of computation~Type theory}
  % \ccsdesc[300]{Software and its engineering~Functional languages}
  % \ccsdesc[500]{Software and its engineering~Polymorphism}
  % \ccsdesc[100]{Software and its engineering~Constraint and logic languages}
  % \ccsdesc[100]{Software and its engineering~Object oriented languages}
  % \ccsdesc[300]{Software and its engineering~Constraints}
  % \ccsdesc[300]{Software and its engineering~Modules / packages}
  % \ccsdesc[300]{Software and its engineering~Semantics}
  % \ccsdesc[500]{Theory of computation~Lambda calculus}
  % \ccsdesc[500]{Theory of computation~Formalisms}
  % \ccsdesc[300]{Theory of computation~Pattern matching}
  % \ccsdesc[500]{Theory of computation~Type structures}
  % \ccsdesc[500]{Theory of computation~Inductive inference}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
% \keywords{Type Inference, System F, Call-by-Push-Value, Polarized Typing, Focalisation, Subtyping}



%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\input{\genDir/tex/01-introduction.tex}

\section{Overview}
\input{\genDir/tex/02-overview.tex}

\section{Declarative System}
\input{\genDir/tex/03-declarative-system.tex}

\section{The Algorithm}
\input{\genDir/tex/04-algorithm.tex}

\section{Algorithm Correctness}
\input{\genDir/tex/05-proof.tex}

\section{Extensions and Future Work}
\input{\genDir/tex/06-extensions.tex}

\section{Conclusion}
\input{\genDir/tex/07-conclusion.tex}

%% Bibliography
%% \balance %% necessary for two-column formats
% \printbibliography
% \bibliography{../biblio}

% \lstset{basicstyle=\ttfamily\scriptsize,keywordstyle=\color{black}\bfseries\underbar,tabsize=8,showstringspaces=false,frame=L,label= ,caption= ,captionpos=b,numbers=none}

% \clearpage
% \appendix
% \input{./tex/appendix/recovery.tex}
% \input{./tex/appendix/drf.tex}

% }

\bibliography{../biblio}

\clearpage
\begin{appendices}
\input{\proofGenDir/content.tex}
\end{appendices}

\clearpage
\tableofcontents
\end{document}
\endinput
