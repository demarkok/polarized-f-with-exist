\UseRawInputEncoding
% vim: ft=tex
\documentclass[a4,natbib=false]{article}
\usepackage[a4paper, total={8in, 10in}]{geometry}
\usepackage{hyperref}
\usepackage{mathpartir}

\input{prelude.tex}


\input{../_build/_gen/included.tex}



% \renewcommand{\ottdruleEOneNVarName}[0]{ Hello \def\@currentlabelname{FOO} \phantomsection  }
% \newcommand{\ottdrulename}[1]{\textsc{#1}}

% \renewcommand{\ottdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}%
%   }\ruleLabel{#4}{#4}}

% \renewcommand{\ottdrule}[4][]{%
%   {\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}}%
%   \mpr@label{\textsc{#1}}%
% }
% \DeclareDocumentCommand \redrule {m m o}{%
%   \inferrule*[vcenter,left={#3:}]{}{#1 \tred #2}
%   \mpr@label{\textsc{#3}}
% }

% \renewcommand{\ottdrulename}[2][#1]{\textsc{#1} \label{}}


% \renewcommand{\ottdruleEOneNVarName}[0]{foo }

% \makeatletter
% \renewcommand{\ottdruleEOneNVar}[1]{\ottdrule[#1]{%
%   }{
%     % \protected@edef\@currentlabelname{foo}
%     \def\@currentlabelname{foo}%
%     \phantomsection
%     \label{boo}
%     \alpha ^{-}   \eqEOne   \alpha ^{-}
%   }{%
%     {\ottdruleEOneNVarName}{}%
%   } }
% \makeatother

\newcommand{\depth}[1]{\ensuremath{\mathsf{depth}(#1)}}
\newcommand{\size}[1]{\ensuremath{\mathsf{size}(#1)}}

\newcommand{\ruleref}[1]{Rule \nameref{#1}}

% ord varset in uN = varset'

\renewcommand{\ottdruleONVarInName}[0]{(Var$_{-\in}^{\text{Ord}}$)}
\renewcommand{\ottdruleONVarNInName}[0]{(Var$_{-\notin}^{\text{Ord}}$)}
\renewcommand{\ottdruleONUVarName}[0]{(UVar$_{-} ^{\text{Ord}}$)}
\renewcommand{\ottdruleOShiftUName}[0]{($\uparrow^{\text{Ord}}$)}
\renewcommand{\ottdruleOArrowName}[0]{($\rightarrow^{\text{Ord}}$)}
\renewcommand{\ottdruleOForallName}[0]{($\forall^{\text{Ord}}$)}


% ord varset in uP = varset'

\renewcommand{\ottdruleOPVarInName}[0]{(Var$_{+\in}^{\text{Ord}}$)}
\renewcommand{\ottdruleOPVarNInName}[0]{(Var$_{+\notin}^{\text{Ord}}$)}
\renewcommand{\ottdruleOPUVarName}[0]{(UVar$_{+}^{\text{Ord}}$)}
\renewcommand{\ottdruleOShiftDName}[0]{($\downarrow^{\text{Ord}}$)}
\renewcommand{\ottdruleOExistsName}[0]{($\exists^{\text{Ord}}$)}


% nf(N) = M
\renewcommand{\ottdruleNrmNVarName}[0]{(Var$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmNUVarName}[0]{(UVar$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmShiftUName}[0]{($\uparrow^{\text{nf}}$)}
\renewcommand{\ottdruleNrmArrowName}[0]{($\rightarrow^{\text{nf}}$)}
\renewcommand{\ottdruleNrmForallName}[0]{($\forall^{\text{nf}}$)}

% nf(P) = Q
\renewcommand{\ottdruleNrmPVarName}[0]{(Var$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmPUVarName}[0]{(UVar$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmShiftDName}[0]{($\downarrow^{\text{nf}}$)}
\renewcommand{\ottdruleNrmExistsName}[0]{($\exists^{\text{nf}}$)}


% N ≈ M

\renewcommand{\ottdruleEOneNVarName}[0]{(Var$_-^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftUName}[0]{($\uparrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneArrowName}[0]{($\rightarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneForallName}[0]{($\forall^{\eqEOne}$)}

% P ≈ Q
\renewcommand{\ottdruleEOnePVarName}[0]{(Var$_+^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftDName}[0]{($\downarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneExistsName}[0]{($\exists^{\eqEOne}$)}


% G ⊢ N ≤1 M

\renewcommand{\ottdruleDOneNVarName}[0]{(Var$_-^{\subDOne}$)}
\renewcommand{\ottdruleDOneShiftUName}[0]{($\uparrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneArrowName}[0]{($\rightarrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneForallName}[0]{($\forall^{\subDOne}$)}

% G ⊢ P ≥1 Q
\renewcommand{\ottdruleDOnePVarName}[0]{(Var$_+^{\supDOne}$)}
\renewcommand{\ottdruleDOneShiftDName}[0]{($\downarrow^{\supDOne}$)}
\renewcommand{\ottdruleDOneExistsName}[0]{($\exists^{\supDOne}$)}


% G ⊢ N ≈1 M
\renewcommand{\ottdruleDOneNDefName}[0]{($\eqDOne_{-}$)}

% G ⊢ P ≈1 Q
\renewcommand{\ottdruleDOnePDefName}[0]{($\eqDOne_{+}$)}



% G ⊨ iP1 ∨ iP2 = iQ
\renewcommand{\ottdruleLUBVarName}[0]{(Var$^{\vee}$)}
\renewcommand{\ottdruleLUBShiftName}[0]{($\downarrow^{\vee}$)}
\renewcommand{\ottdruleLUBExistsName}[0]{($\exists^{\vee}$)}
\renewcommand{\ottdruleLUBUpgradeName}[0]{(Upg)}


% G ; Θ ⊨ uN ≤ iM ⫤ us
\renewcommand{\ottdruleANVarName}[0]{(Var$_-^{\subA}$)}
\renewcommand{\ottdruleAShiftUName}[0]{($\uparrow^{\subA}$)}
\renewcommand{\ottdruleAArrowName}[0]{($\rightarrow^{\subA}$)}
\renewcommand{\ottdruleAForallName}[0]{($\forall^{\subA}$)}

% G ; Θ ⊨ iP ≥ uQ ⫤ us
\renewcommand{\ottdruleAPVarName}[0]{(Var$_+^{\supA}$)}
\renewcommand{\ottdruleAShiftDName}[0]{($\downarrow^{\supA}$)}
\renewcommand{\ottdruleAExistsName}[0]{($\exists^{\supA}$)}
\renewcommand{\ottdruleAPUVarName}[0]{(UVar$^{\supA}$)}


% Γ ⊢ scE1 & scE2 = scE3 :: :: E :: 'E'
\renewcommand{\ottdruleSCMESupSupName}[0]{$([[≥]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSCMEEqSupName}[0]{$([[≈]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSCMESupEqName}[0]{$([[≥]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSCMEPEqEqName}[0]{$([[≈]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSCMENEqEqName}[0]{$([[≈]]\&^{-}[[≈]])$}

% Γ ; Θ ⊨ uN ≈u iM ⫤ UC 
\renewcommand{\ottdruleUNVarName}[0]{(Var$_{-}^{[[≈u]]}$)}
\renewcommand{\ottdruleUShiftUName}[0]{($\uparrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUArrowName}[0]{($\rightarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUForallName}[0]{($\forall^{[[≈u]]}$)}
\renewcommand{\ottdruleUNUVarName}[0]{(UVar$_{-}^{[[≈u]]}$)}

% Γ ; Θ ⊨ uP ≈u iQ ⫤ UC 
\renewcommand{\ottdruleUPVarName}[0]{(Var$_{+}^{[[≈u]]}$)}
\renewcommand{\ottdruleUShiftDName}[0]{($\downarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUExistsName}[0]{($\exists^{[[≈u]]}$)}
\renewcommand{\ottdruleUPUVarName}[0]{(UVar$_{+}^{[[≈u]]}$)}

% G ⊨ iP1 ≈au iP2 ⫤ ( Ξ , uQ , aus1 , aus2 )
\renewcommand{\ottdruleAUPVarName}[0]{(Var$_{+}^{[[≈au]]}$)}
\renewcommand{\ottdruleAUShiftDName}[0]{($\downarrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUExistsName}[0]{($\exists^{[[≈au]]}$)}

% G ⊨ iN1 ≈au iN2 ⫤ ( Ξ , uM , aus1 , aus2 )
\renewcommand{\ottdruleAUNVarName}[0]{(Var$_{-}^{[[≈au]]}$)}
\renewcommand{\ottdruleAUShiftUName}[0]{($\uparrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUForallName}[0]{($\forall^{[[≈au]]}$)}
\renewcommand{\ottdruleAUArrowName}[0]{($\rightarrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUAUName}[0]{(AU$_{-}$)}

% Γ ⊢ iN 
\renewcommand{\ottdruleWFTNVarName}[0]{(Var$_{-}^{\text{WF}}$)}
\renewcommand{\ottdruleWFTShiftUName}[0]{($\uparrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFTArrowName}[0]{($\rightarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFTForallName}[0]{($\forall^{\text{WF}}$)}

% Γ ⊢ iP
\renewcommand{\ottdruleWFTPVarName}[0]{(Var$_{+}^{\text{WF}}$)}
\renewcommand{\ottdruleWFTShiftDName}[0]{($\downarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFTExistsName}[0]{($\exists^{\text{WF}}$)}

% Γ ; Ξ ⊢ uN
\renewcommand{\ottdruleWFATNVarName}[0]{(Var$_{-}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATNUVarName}[0]{(UVar$_{-}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATShiftUName}[0]{($\uparrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFATArrowName}[0]{($\rightarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFATForallName}[0]{($\forall^{\text{WF}}$)}

% Γ ; Ξ ⊢ uP
\renewcommand{\ottdruleWFATPVarName}[0]{(Var$_{+}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATPUVarName}[0]{(UVar$_{+}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATShiftDName}[0]{($\downarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFATExistsName}[0]{($\exists^{\text{WF}}$)}

% Γ ⊢ iP : scE
\renewcommand{\ottdruleSATSCESupName}[0]{($[[:≥]]_{+}^\text{sat}$)}
\renewcommand{\ottdruleSATSCEPEqName}[0]{($[[:≈]]_{+}^\text{sat}$)}

% Γ ⊢ iN : scE
\renewcommand{\ottdruleSATSCENEqName}[0]{($[[:≈]]_{-}^\text{sat}$)}

% Γ ; Φ ⊢ v : iP 
\renewcommand{\ottdruleDTVarName}[0]{(Var$^{\text{inf}}$)}
\renewcommand{\ottdruleDTThunkName}[0]{($\{\}^{\text{inf}}$)}
\renewcommand{\ottdruleDTPAnnotName}[0]{(ann$_+^{\text{inf}}$)}
\renewcommand{\ottdruleDTPEquivName}[0]{($[[≈]]_+^{\text{inf}}$)}

% Γ ; Φ ⊢ c : iN 
\renewcommand{\ottdruleDTtLamName}[0]{($\lambda^{\text{inf}}$)}
\renewcommand{\ottdruleDTTLamName}[0]{($\Lambda^{\text{inf}}$)}
\renewcommand{\ottdruleDTReturnName}[0]{(ret$^{\text{inf}}$)}
\renewcommand{\ottdruleDTVarLetName}[0]{(let$^{\text{inf}}$)}
\renewcommand{\ottdruleDTAppLetName}[0]{(let$_@^{\text{inf}}$)}
\renewcommand{\ottdruleDTAppLetAnnName}[0]{(let$_{:@}^{\text{inf}}$)}
\renewcommand{\ottdruleDTUnpackName}[0]{(let$_{\exists}^{\text{inf}}$)}
\renewcommand{\ottdruleDTNAnnotName}[0]{(ann$_-^{\text{inf}}$)}
\renewcommand{\ottdruleDTNEquivName}[0]{($[[≈]]_-^{\text{inf}}$)}

% Γ ; Φ ⊢ iN ● args ⇒> iM 
\renewcommand{\ottdruleDTEmptyAppName}[0]{($\emptyset_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleDTArrowAppName}[0]{($\rightarrow_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleDTForallAppName}[0]{($\forall_{[[●]][[⇒>]]}^{\text{inf}}$)}



% Γ ; Φ ⊨ v : iP  
\renewcommand{\ottdruleATVarName}[0]{(Var$^{\text{inf}}$)}
\renewcommand{\ottdruleATThunkName}[0]{($\{\}^{\text{inf}}$)}
\renewcommand{\ottdruleATPAnnotName}[0]{(ann$_+^{\text{inf}}$)}

% Γ ; Φ ⊨ c : iN 
\renewcommand{\ottdruleATtLamName}[0]{($\lambda^{\text{inf}}$)}
\renewcommand{\ottdruleATTLamName}[0]{($\Lambda^{\text{inf}}$)}
\renewcommand{\ottdruleATReturnName}[0]{(ret$^{\text{inf}}$)}
\renewcommand{\ottdruleATVarLetName}[0]{(let$^{\text{inf}}$)}
\renewcommand{\ottdruleATAppLetName}[0]{(let$_@^{\text{inf}}$)}
\renewcommand{\ottdruleATAppLetAnnName}[0]{(let$_{:@}^{\text{inf}}$)}
\renewcommand{\ottdruleATUnpackName}[0]{(let$_{\exists}^{\text{inf}}$)}
\renewcommand{\ottdruleATNAnnotName}[0]{(ann$_-^{\text{inf}}$)}

% Γ ; Φ ; Θ1 ⊨ uN ● args ⇒> uM ⫤ Θ2 ; SC 
\renewcommand{\ottdruleATEmptyAppName}[0]{($\emptyset_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleATArrowAppName}[0]{($\rightarrow_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleATForallAppName}[0]{($\forall_{[[●]][[⇒>]]}^{\text{inf}}$)}

% scE1 singular with iP
\renewcommand{\ottdruleSINGPEqName}[0]{($[[≈]]_{+}^{\text{sing}}$)}
\renewcommand{\ottdruleSINGSupVarName}[0]{($[[:≥]]\alpha^{\text{sing}}$)}
\renewcommand{\ottdruleSINGSupShiftName}[0]{($[[:≥]][[↓]]^{\text{sing}}$)}

% scE1 singular with iN
\renewcommand{\ottdruleSINGNEqName}[0]{($[[≈]]_{-}^{\text{sing}}$)}

\begin{document}

\tableofcontents

\newpage

\section{Declarative Type Systems}

\subsection{Grammar}
We assume that there is an infinite set of positive and 
negative \emph{type} variables. Positive type variables are denoted as 
$[[α⁺]]$, $[[β⁺]]$, $[[γ⁺]]$, etc.
Negative type variables are denoted as $[[α⁻]]$, $[[β⁻]]$, $[[γ⁻]]$, etc.
We assume there is an infinite set of \emph{term} variables,
which are denoted as $[[x]]$, $[[y]]$, $[[z]]$, etc.
A list of objects (variables, types or terms) is denoted by
an overline arrow. For instance, $[[pas]]$ is a list of positive type variables, 
$[[nbs]]$ is a list of negative type variables, 
$[[args]]$ is a list of values, which are arguments of a function.
$[[fv(iP)]]$ and $[[fv(iN)]]$ denote the set of free variables 
in a type $[[iP]]$ and $[[iN]]$, respectively.

\bigskip

% \ottgrammartabular{
%   \ottiP\ottinterrule
%   \ottiN\ottinterrule
% }

\begin{definition}[Declarative Types]
  \hfill
  \begin{multicols}{2}
    \ottgrammartabular{
      \ottiN\ottinterrule
    }

    \ottgrammartabular{
      \ottiP\ottinterrule
    }
    \columnbreak
  \end{multicols}
\end{definition}

\subsection{Equalities}
For simplicity, we assume alpha-equivalent terms equal.
This way, we assume that substitutions do not capture bound variables.
Besides, we equate
$[[∀pas.∀pbs.iN]]$ with $[[∀pas,pbs.iN]]$, 
as well as $[[∃nas.∃nbs.iP]]$ with $[[∃nas,nbs.iP]]$,
and lift these equations transitively and congruently 
to the whole system.

\subsection{Contexts and Well-formedness}

\begin{definition}[Declarative Type Context]
  \hfill \\
  Declarative type context $[[Γ]]$ is represented by a set of 
  type variables. The concatenation $[[Γ1, Γ2]]$ means the 
  union of two contexts $[[Γ1 ∪ Γ2]]$.
\end{definition}

$[[Γ ⊢ iP]]$ and $[[Γ ⊢ iN]]$ denote that the type is well-formed in the context $[[Γ]]$,
which, in fact, means that each free type variable of the type is contained in $[[Γ]]$
(it will be shown later in \cref{lemma:wf-soundness,lemma:wf-ctxt-equiv}).

Notice that checking the well-formedness of a type
is an \emph{algorithmic} procedure, in which 
both the context and the type are considered inputs.
In other words, it is syntax-directed and mode-correct 
(according to \cite{dunfieldBidirectionalTyping2020}), 
which means that 

\begin{algorithm}[Type Well-formedness]
  \hfill
  
  \begin{multicols}{2}
  \ottdefnWFTNiWF{}
  \columnbreak

  \ottdefnWFTPiWF{}
  \end{multicols}

\end{algorithm}


\subsection{Substitutions}

\begin{definition}[Substitution]
  Substitutions (denoted as $[[σ]]$) 
  are represented by total functions form variables to types, preserving the polarity. 
\end{definition}

\begin{algorithm}[Substitution Application]
  Substitution application is denoted as $[[ [σ]iP ]]$ and $[[ [σ]iN ]]$.
  It is defined naturally as follows:
    \begin{multicols}{2}
      \begin{itemize}
        \item[] $[[ [σ]α⁺ ]] = [[σ]] ([[α⁺]])$;
        \item[] $[[ [σ]α⁻ ]] = [[σ]] ([[α⁻]])$;
        \item[] $[[ [σ]↓iN ]] = [[↓[σ]iN]]$;
        \item[] $[[ [σ]↑iP ]] = [[↑[σ]iP]]$;
        \item[] $[[ [σ](iP → iN) ]] = [[ [σ]iP → [σ]iN ]]$.
        \item[] $[[ [σ]∃nas.iQ ]] = [[∃nas.[σ]iQ]]$, 
        \item[] $[[ [σ]∀pas.iN ]] = [[∀pas.[σ]iN]]$ (here we assume that $[[nas]]$ and $[[pas]]$ are lists of fresh variables, 
          that is the variable capture never happens);
      \end{itemize}
    \end{multicols}
\end{algorithm}

\begin{definition}[Substitution Signature]
  The signature $[[Γ' ⊢ σ : Γ]]$ means that
  \begin{enumerate}
    \item for any $[[α± ∊ Γ]], [[ Γ' ⊢ [σ]α± ]]$; and
    \item for any $[[α± ∉ Γ']], [[ [σ]α± = α± ]]$.
  \end{enumerate}
\end{definition}

A substitution can be restricted to a set of variables. 
The restricted substitution is define as expected. 
\begin{definition}[Subsitution Restriction]
  The specification $[[σ  | varset]]$ is defined as
  a function such that 
  \begin{enumerate}
    \item $[[σ|varset]]([[α± ]]) = [[σ]]([[α± ]])$, if $[[α± ]] \in [[varset]]$; and
    \item $[[σ|varset]]([[α± ]]) = [[α± ]]$, if $[[α± ]] \notin [[varset]]$.
  \end{enumerate}
\end{definition}

Two substitutions can be composed in two ways:
$[[σ2 ○ σ1]]$ corresponds to a consecutive application of $[[σ1]]$ and $[[σ2]]$,
while $[[σ2 <=< σ1]]$
depends on a signature of $[[σ1]]$ and modifies $[[σ1]]$ by applying
$[[σ2]]$ to its results on the domain.
\begin{definition}[Substitution Composition]
  $[[σ2 ○ σ1]]$ is defined as a function such that
  $[[σ2 ○ σ1]]([[α± ]]) = [[σ2]]([[σ1]]([[α± ]]))$.
\end{definition}

\begin{definition}[Monadic Substitution Composition]
  Suppose that $[[Γ' ⊢ σ1 : Γ]]$.
  Then we define $[[σ2 <=< σ1]]$ as $[[(σ2 ○ σ1)|Γ]]$.
\end{definition}
Notice that the result of $[[σ2 <=< σ1]]$ depends on the 
specification of $[[σ1]]$, which is not unique. 
However, we assume that the used specification clear from the 
context of the proof. 

\begin{definition}[Equivalent Substitutions]
  The substitution equivalence judgement $[[Γ' ⊢ σ1 ≈ σ2 : Γ]]$ 
  indicates that on the domain $[[Γ]]$, 
  the result of $[[σ1]]$ and $[[σ2]]$ are equivalent in context $[[Γ']]$.
  Formally, for any $[[α± ∊ Γ]], [[ Γ' ⊢ [σ1]α± ≈ [σ2]α± ]]$.
\end{definition}

Sometimes it is convenient to construct substitution 
explicitly mapping each variable from a list (or a set)
to a type. Such substitutions are denoted as $[[iPs / pas]]$
and $[[iNs / nas]]$, where $[[iPs]]$ and $[[iNs]]$ are lists of 
the corresponding types.
\begin{definition}[Explicit Substitution]
  \hfill
  \begin{itemize}
    \item [$-$]
      Suppose that $[[nas]]$ is a list of negative type variables,
      and $[[iNs]]$ is a list of negative types of the same length.
      Then $[[iNs / nas]]$ denotes a substitution such that 
      \begin{enumerate}
        \item for $[[αi⁺ ∊ {nas}]]$, $[[ [iNs / nas] αi⁺]] = [[iNi]]$;
        \item for $[[β⁺ ∉ {nas}]]$, $[[ [iNs / nas] β⁺]] = [[β⁺]]$.
      \end{enumerate}
    \item [$+$]
      Positive explicit substitution $[[iPs / pas]]$
      is defined symmetrically.
  \end{itemize}
\end{definition}


\subsection{Declarative Subtyping}
Subtyping is one of the key mechanism of our system. 
It realizes the polymorphism: abstract $[[∀]]$ and 
$[[∃]]$ types can be used where concrete types are expected,
exactly because the subtyping relation between them.


\begin{definition} 
  \label{def:subDOne}
  \hfill
  
  \begin{multicols}{2}
    \ottdefnDOneNsub{}
    \columnbreak\\
    \ottdefnDOnePsup{}
  \end{multicols}
  
  \begin{multicols}{2}
    \ottdefnDOneNeq{}
    \columnbreak\\
    \ottdefnDOnePeq{}
  \end{multicols}
\end{definition}

The following observations about the declarative subtyping are worth noting:
\begin{itemize}
  \item \ruleref{\ottdruleDOneNVarLabel} and \ruleref{\ottdruleDOnePVarLabel}
    make the subtyping reflexive on variables (and further, on any type).
  \item \ruleref{\ottdruleDOneArrowLabel} is standard: the arrow is covariant on the
    resulting type and contravariant on the argument type.
  \item \ruleref{\ottdruleDOneShiftDLabel}  and \ruleref{\ottdruleDOneShiftULabel} are non-standard:
    the subtyping is \emph{invariant} for shifts. 
    This way, the subtyping of shifted types in one direction implies the subtyping
    in the opposite direction.
    Although this rule restricts the
    subtyping relation, it makes the system decidable.
  \item \ruleref{\ottdruleDOneForallLabel} and \ruleref{\ottdruleDOneExistsLabel} are the only
    non-algorithmic rules: the substitution for the quantified variable is
    not specified, those, these rules `drive' the subtyping relation.
\end{itemize}

In the next section, we present the sound and complete algorithm
checking whether one type is a subtype of another according to \cref{def:subDOne}. 

\section{Algorithmic Type System}

\subsection{Grammar}

In the algorithmic system, we extend the grammar of types
by adding positive and negative \emph{algorithmic variables}
($[[α̂⁺]]$, $[[β̂⁺]]$, $[[γ̂⁺]]$, etc. and $[[α̂⁻]]$, $[[β̂⁻]]$, $[[γ̂⁻]]$, etc.).
They represent the unknown types, which will be inferred by the algorithm.
This way, we add two base cases to the grammar of 
positive and negative types, and use highlight to denote that the type
can potentially contain algorithmic variables.

\begin{definition}[Algorithmic Types]
  \label{def:algo-types}
  \hfill\\
  \begin{multicols}{2}
    \ottgrammartabular{
      \ottuN\ottinterrule
    }

    \ottgrammartabular{
      \ottuP\ottinterrule
    }
    \columnbreak
  \end{multicols}
\end{definition}

\subsection{Fresh Variable Selection}
\label{sec:fresh-selection}
Both the subtyping and the type inference algorithm
rely on the ability to select fresh, unused variables.
For a set of variables $[[varset]]$, it is indicated as 
$[[varset are fresh]]$ in the inference rules.
We assume that the selection subroutine always succeeds and is 
deterministic. In other words, whenever it is called in 
an algorithmic inference rule, it returns the same result, 
uniquely determined by the input of this rule.

\subsection{Variable Algorithmization}
\label{sec:variable-algorithmization}

In several places of our algorithm, in particular, during
algorithmic subtyping,
we turn a declarative type into the algorithmic one
via replacing certain type variables with fresh algorithmic variables.
We call this procedure \emph{variable algorithmization}, and define it as follows.

\begin{definition}[Variable Algorithmization]
  Suppose that $[[nas]]$ is a list of negative type variables
  and $[[nuas]]$ is a list of negative algorithmic variables of the same length. 
  Then $[[ nuas/nas ]]$ is a substitution-like procedure replacing each $[[αi⁻ ∊ {nas}]]$
  in a type for $[[αî⁻ ∊ {nuas}]]$.
\end{definition}

Conversely, we have the opposite procedure turning algorithmic type variables
into declarative type variables via \emph{dealgorithmization}.

\begin{definition}[Variable Dealgorithmization]
  Suppose that $[[nuas]]$ is a list of negative algorithmic variables
  and $[[nas]]$ is a list of negative type variables of the same length. 
  Then $[[ nas/nuas ]]$ is a substitution-like procedure replacing each
  $[[αî⁻ ∊ {nuas}]]$ in a type for $[[αi⁻ ∊ {nas}]]$.
\end{definition}


\subsection{Contexts and Well-formedness}

\begin{definition}[Algorithmic Type Context $[[Ξ]]$]
  \hfill \\
  Algorithmic type context $[[Ξ]]$ is represented by a set of 
  \emph{algorithmic} type variables ($[[α̂⁺]]$, $[[α̂⁻]]$, $[[β̂⁺]]$, \dots).
  The concatenation $[[Ξ1, Ξ2]]$ means the union of two contexts $[[Ξ1 ∪ Ξ2]]$.
\end{definition}

$[[Γ ; Ξ ⊢ uP]]$ and $[[Γ ; Ξ ⊢ uN]]$ are used to denote
that the algorithmic type is well-formed in the contexts
$[[Γ]]$ and $[[Ξ]]$, which means that each algorithmic variable
of the type is contained in $[[Ξ]]$, and each free declarative type variable
of the type is contained in $[[Γ]]$.

\begin{algorithm}[Algorithmic Type Well-formedness]
  \hfill
  
  \begin{multicols}{2}
  \ottdefnWFATNauWF{}
  \columnbreak

  \ottdefnWFATPauWF{}
  \end{multicols}

\end{algorithm}


Algorithmic Type Context are used in the unification algorithm.
In the subtyping algorithm, 
the context needs to remember additional information.
In the subtyping context, each algorithmic variable is associated with a
context it must be instantiated in 
(i.e. the context in which the type replacing the variable must be well-formed).
This association is represented by \emph{algorithmic subtyping context} $[[Θ]]$.
\begin{definition}[Algorithmic Subtyping Context $[[Θ]]$]
  \hfill \\
  Algorithmic Subtyping Context $[[Θ]]$ is represented by a set of 
  entries of form $[[ α̂⁺[Γ] ]]$ and $[[ α̂⁻[Γ] ]]$,
  where $[[α̂⁺]]$ and $[[α̂⁻]]$ are algorithmic variables,
  and $[[Γ]]$ is a context in which they must be instantiated.
  We assume that no two entries associating the same variable
  appear in $[[Θ]]$.

  $[[dom(Θ)]]$ denotes the set of variables appearing in $[[Θ]]$:
  $[[dom(Θ)]] = \{ [[α̂±]] \mid [[α̂±[Γ] ]] \in [[Θ]] \}$.
  If $[[ α̂±[Γ] ]] \in [[Θ]]$, we denote $[[Γ]]$ as $[[Θ(α̂±)]]$.
\end{definition}


\subsection{Subsitutions}

Substitution that operates on algorithmic type variables is denoted as
$[[uσ]]$. It is defined as a total function from algorithmic 
type variables to \emph{declarative} types, preserving the polarity.

The signature $[[Θ ⊢ uσ : Ξ]]$ means that
$[[Ξ ⊆ dom(Θ)]]$ and 
$[[uσ]]$ maps each algorithmic variable 
from $[[Ξ]]$ to a type well-formed in $[[Θ(α̂±)]]$;
and for each variable not appearing in $[[dom(Θ)]]$, 
it acts as identity.

\begin{definition}[Signature of Algorithmic Substitution]
  \label{def:algo-subst-sig}
  \hfill
  \begin{itemize}
    \item $[[Θ ⊢ uσ : Ξ]]$ means that
      \begin{enumerate}
        \item for any $[[α̂± ∊ Ξ]]$,
          there exists $[[Γ]]$ such that $[[ α̂±[Γ] ∊ Θ ]]$
          and $[[ Γ ⊢ [uσ]α̂± ]]$; 
        \item for any $[[ α̂± ∉ Ξ]]$, $[[ [uσ]α̂± ]] =  [[ α̂± ]]$.
      \end{enumerate}
    \item $[[Γ ⊢ uσ : Ξ]]$ means that
      \begin{enumerate}
        \item for any $[[α̂± ∊ Ξ]]$, $[[ Γ ⊢ [uσ]α̂± ]]$; 
        \item for any $[[ α̂± ∉ Ξ]]$, $[[ [uσ]α̂± ]] =  [[ α̂± ]]$.
      \end{enumerate}
  \end{itemize}
\end{definition}

In the anti-unification algorithm, we use another kind of substitution.
In contrast to algorithmic substitution $[[uσ]]$,
it allows mapping algorithmic variables to
\emph{algorithmic} types.
Additionally, anti-unification substitution is restricted to the
\emph{negative} segment of the language.
Anti-unification substitution is denoted as $[[aus]]$ and $[[ausr]]$.a

The pair of contexts $[[Γ]]$ and $[[Ξ]]$,
in which the results of an anti-unification substitution 
are formed, is fixed for this substitution.
This way, $[[Γ; Ξ2 ⊢ aus : Ξ1]]$ means that $[[aus]]$ maps each negative algorithmic
variable appearing in $[[Ξ1]]$ to a term well-formed in $[[Γ]]$ and $[[Ξ2]]$.

\begin{definition}[Signature of Anti-unification substitution]
  $[[Γ; Ξ2 ⊢ aus : Ξ1]]$ means that
  \begin{enumerate}
    \item for any $[[ α̂⁻ ∊ Ξ1]]$, $[[ Γ; Ξ2 ⊢ [aus]α̂⁻ ]]$ and
    \item for any $[[ α̂⁻ ∉ Ξ1]]$, $[[ [aus]α̂⁻ = α̂⁻ ]]$.
  \end{enumerate}
\end{definition}

\subsection{Equivalence and Normalization}

The subtyping-induced equivalence (\cref{def:subDOne}) is non-trivial:
there are types that are subtypes of each other but not equal. 
For example, $[[∀α⁺,β⁺.α⁺ → ↑β⁺]]$ is a subtype and a supertype of $[[∀α⁺,β⁺.β⁺ → ↑α⁺]]$
and of, for example, $[[∀α⁺,β⁺.β⁺ → ↑∃γ⁻.α⁺]]$, 
although these types are not alpha-equivalent.
For the subtyping algorithm, it is crucial to be able to check whether
two types are equivalent, without checking mutual subtyping. 
For this purpose we define the normalization procedure, 
which allows us to uniformly choose the representative type of the equivalence class.
This way, the equivalence checking is reduced to normalization and equality checking. 

For clarification of the proofs and better understanding of the system, 
we introduce an intermediate relation---\emph{declarative equivalence}. 
As will be shown in \cref{lemma:equiv-soundness,lemma:equiv-completeness}, 
this relation is equivalent to the subtyping-induced equivalence, but does not 
depend on it. Although this relation is not defined algorithmically, 
it gives the intuition of what types our system considers equivalent.
Specifically, in addition to \emph{alpha-equivalence}, 
our system allows for \emph{reordering of adjacent quantifiers},
and \emph{introduction/elimination of unused quantifiers}.

The non-trivial rules of the declarative equivalence are
\ruleref{\ottdruleEOneForallLabel} and \ruleref{\ottdruleEOneExistsLabel}.
Intuitively, the variable bijection $[[μ]]$ reorders the quantifiers before
the recursive call on the body of the quantified type. 
It will be covered formally in \cref{sec:decl-equiv-lemmas}.

\begin{definition}[Declarative Type Equivalence]
  \hfill
  
  \begin{multicols}{2}
  \ottdefnEOneNeq{}
  \columnbreak\\
  \ottdefnEOnePeq{}
  \end{multicols}

\end{definition}

As the equivalence includes arbitrary reordering of quantified variables,
the normalization procedure is needed to choose the canonical order.
For this purpose, we introduce an auxiliary procedure---variable ordering. 
Intuitively, $[[ord varset in iN]]$ returns a list of variables from $[[varset]]$
in the order they appear in $[[iN]]$.

\begin{algorithm}[Variable Ordering]
  \label{alg:var-ordering}
  \hfill
  
  \begin{multicols}{2}
  \ottdefnONVar{}
  \columnbreak\\
  \ottdefnOPVar{}
  \end{multicols}

  Analogously, the variable can be ordered in 
  an \emph{algorithmic} type ($[[ord varset in uP]]$ and 
  $[[ord varset in uN]]$). In these cases, we treat the algorithmic variables
  as if they were declarative variables.

\end{algorithm}

Next, we use the variable ordering in the normalization procedure. 
Specifically, normalization recursively traverses the type, 
and for each quantified case reorders the quantified variables in a 
canonical order dictated by \cref{alg:var-ordering}, removing unused ones.

\begin{algorithm}[Type Normalization]
  \hfill
  
  \begin{multicols}{2}
  \ottdefnNrmNNorm{}
  \columnbreak\\
  \ottdefnNrmPNorm{}
  \end{multicols}

  Analogously,  we define normalization of algorithmic types 
  by adding base cases:

  \begin{multicols}{2}
  \ottdefnNrmuNNorm{}
  \columnbreak\\
  \ottdefnNrmuPNorm{}
  \end{multicols}

\end{algorithm}

\begin{algorithm}[Substitution Normalization]
  For a substitution $[[σ]]$, we define $[[nf(σ)]]$
  as a substitution that maps $[[α±]]$ into $[[nf([σ]α±)]]$.
\end{algorithm}

The rest of this chapter is devoted to the
central algorithm of the type system---the subtyping algorithm. 
\Cref{fig:subtyping-algo} shows the dependency graph of the subtyping algorithm.
The nodes represent the algorithmic procedures, and the edge $A \to B$ means that 
$A$ uses $B$ as a sub-procedure.



\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    [>=stealth',node distance=2.6cm,every node/.style={draw,rectangle},every text node part/.style={align=center}]


    % Define nodes
    \node[] (1) {Negative Subtyping\\$[[Γ ; Θ ⊨ uN ≤ iM ⫤ SC]]$\\(\cref{sec:subtyping})};
    \node[below of=1] (3) {Positive Subtyping\\$[[Γ ; Θ ⊨ uP ≥ iQ ⫤ SC]]$\\(\cref{sec:subtyping})};
    \node[left=2cm of 3] (2) {Subtyping Constraint Merge\\$[[Θ ⊢ SC1 & SC2 = SC3]]$\\(\cref{sec:constraint-merge})};
    \node[right=2cm of 3] (5) {Unification\\ $[[Γ ; Θ ⊨ uN ≈u iM ⫤ UC]]$\\ $[[Γ ; Θ ⊨ uP ≈u iQ ⫤ UC]]$\\(\cref{sec:unification})};
    \node[below of=3] (4) {Upgrade\\$[[upgrade Γ ⊢ iP to Δ = iQ]]$\\(\cref{sec:lub})};
    \node[below of=2] (6) {Least Upper Bound\\$[[Γ ⊨ iP1 ∨ iP2 = iQ]]$\\(\cref{sec:lub})};
    \node[below of=6] (7) {Anti-Unification\\$[[Γ ⊨ iP1 ≈au iP2 ⫤ ( Ξ , uQ , aus1 , aus2 )]]$\\$[[Γ ⊨ iN1 ≈au iN2 ⫤ ( Ξ , uM , aus1 , aus2 )]]$\\(\cref{sec:antiunification})};
    \node[below of=5] (8) {Unification Constraint Merge\\$[[Θ ⊢ UC1 & UC2 = UC3]]$\\(\cref{sec:constraint-merge})};
    
    % Define edges
    \draw[->] (1) to (2);
    \draw[->] (1) to (3);
    \draw[->] (1) to (5);
    \draw[->] (2) to (3);
    \draw[->] (2) to (6);
    \draw[->] (3) to (4);
    \draw[->] (3) to (5);
    \draw[->] (4) to (6);
    \draw[->] (5) to (8);
    \draw[->] (6) to (7);
  \end{tikzpicture}  
  \caption{Dependency graph of the subtyping algorithm}
  \label{fig:subtyping-algo}
\end{figure}

\subsection{Subtyping}
\label{sec:subtyping}

Now, we present the subtyping algorithm itself.
Although the algorithm is presented as a single procedure,
is important for the structure of the proof that the positive subtyping algorithm
does not invoke the negative one. This way, the correctness of the positive 
subtyping will be proved independently, and used afterwards to prove the
correctness of the negative subtyping.


\begin{algorithm}[Subtyping]
  \hfill
  
  \begin{multicols}{2}
  \ottdefnANsub{}
  \columnbreak\\
  \ottdefnAPsup{}
  \end{multicols}
\end{algorithm}

The inputs of the subtyping algorithm are the declarative context $[[Γ]]$,
the subtyping context $[[Θ]]$ (it specifies in which contexts the algorithmic variables
must be instantiated), and the types themselves: $[[uN]]$ and $[[iM]]$ for the negative case,
and $[[uP]]$ and $[[iQ]]$ for the positive case. 
As one of the invariants, we require
$[[iM]]$ and $[[iQ]]$ to be declarative (i.e. not containing algorithmic variables).
The output of the algorithm is a set of \emph{subtyping constraints} $[[SC]]$,
which will be discussed in the next section.

Let us overview the inference rules of the subtyping algorithm.
\begin{itemize}
  \item \ruleref{\ottdruleANVarLabel} and \ruleref{\ottdruleAPVarLabel} 
    are the base cases. They copy the corresponding declarative rules and
    ensure the reflexivity.
  \item \ruleref{\ottdruleAPUVarLabel} is the only case generating 
    subtyping constraints. In this case, we must ensure
    that the resulting constrains guarantees that the instantiation of 
    $[[â⁺]]$ is a supertype of $[[iP]]$.
    However, the obvious constraint $[[â⁺ :≥ iP]]$ might be problematic
    if  $[[iP]]$ is not well-formed in $[[Θ(â⁺)]]$. For this reason,
    we use the \emph{upgrade} procedure (it will be covered in \cref{sec:lub})
    to find the minimal supertype of $[[iP]]$, which is well-formed in $[[Θ(â⁺)]]$. 

    Notice that this rule does not have a negative counterpart. This is
    because one one of the important invariants of the algorithm: 
    in the negative subtyping, only positive algorithmic variables
    can occur in the types. 
    
  \item \ruleref{\ottdruleAShiftDLabel} and \ruleref{\ottdruleAShiftULabel} are the
    \emph{shift} rules. According to the declarative system,
    shifted subtyping requires equivalence. In presence of the algorithmic 
    variables, it means that the left and the right-hand sides of the subtyping
    must be unified. Hence, the shift rules invoke the unification algorithm, 
    which will be discussed in \cref{sec:unification}. The unification 
    returns the minimal set of constraints $[[UC]]$, which is necessary
    and sufficient for the subtyping. 

  \item \ruleref{\ottdruleAArrowLabel}.
    In this case, the algorithm makes two calls:
    a recursive call to the negative subtyping algorithm for the argument types,
    and a call to the positive subtyping algorithm for the result types.
    After that, the resulting constraints are merged using the
    \emph{subtyping constraint merge} procedure, 
    which is discussed in \cref{sec:constraint-merge}.
  \item \ruleref{\ottdruleAForallLabel} and \ruleref{\ottdruleAExistsLabel}
    are symmetric. These are the only places where 
    the algorithmic variables are introduced.
    It is done by algorithmization (\cref{sec:variable-algorithmization}) 
    of the quantified variables: these variables are replaced by 
    fresh algorithmic variables in the body of the quantified type,
    the algorithmic variables are added to the subtyping context $[[Θ]]$,
    after that the recursive call is made. Notice that the declarative context
    $[[Γ]]$ is extended by the quantified variables from the right-hand side,
    which matches the declarative system.
\end{itemize}


Then soundness lemma (\cref{lemma:pos-subt-soundness,lemma:neg-subt-soundness}) 
and completeness (\cref{lemma:pos-subt-completeness,lemma:neg-subt-completeness})
of the algorithm together give us the following simplified theorem:

\begin{theorempreview}[Correctness of subtyping algorithm]
  \hfill
  \begin{itemize}
    \item [$-$]  $[[ Γ ; · ⊨ uN ≤ iM ⫤ · ]]$ is equivalent to $[[ Γ ⊢ iN ≤ iM ]]$;
    \item [$+$] $[[ Γ ; · ⊨ uP ≥ iQ ⫤ · ]]$ is equivalent to $[[ Γ ⊢ iP ≥ iQ ]]$.
  \end{itemize}
\end{theorempreview}


\subsection{Constraints}

Unification and subtyping algorithms are based on the constraint generation.
The constraints are represented by set of constraint entries.

\begin{definition}[Unification Constraint]
  \hfill
  \begin{description}
    \item[unification entry] (denoted as $[[ucE]]$) is an expression of shape 
      $[[pua :≈ iP]]$ or $[[nua :≈ iN]]$;
    \item[unification constraint] (denoted as $[[UC]]$) is a set of 
      unification constraint entries.
      We denote $\{[[α̂±]] \mid [[ucE ∊ UC]] \text{ restricting $[[α̂±]]$ }\}$ 
      as $[[dom(UC)]]$.
  \end{description}
\end{definition}

However, in the subtyping, we need to consider more general
kind of constraints. Specifically,
subtyping constraint entries can restrict a variable
not only to be equivalent to a certain type, but
also to be a supertype of a positive type.

\begin{definition}[Subtyping Constraint]
  \hfill
  \begin{description}
    \item[subtyping entry] (denoted as $[[scE]]$) is an expression of shape 
      $[[pua :≥ iP]]$, $[[nua :≈ iN]]$, or $[[pua :≈ iP]]$;
    \item[subtyping constraint] (denoted as $[[SC]]$) is a set of subtyping constraint entries.
      We denote $\{[[α̂±]] \mid [[scE ∊ SC]] \text{ restricting $[[α̂±]]$ }\}$ 
      as $[[dom(SC)]]$.
  \end{description}
\end{definition}

\begin{definition}[Well-formed Constraint Entry]
  We say that a constraint entry is well-formed in a context $[[Γ]]$ if
  its associated type is well-formed in $[[Γ]]$.
  \begin{itemize}
    \item[] $[[Γ ⊢ pua :≥ iP]]$ ~iff~ $[[Γ ⊢ iP]]$;
    \item[] $[[Γ ⊢ pua :≈ iP]]$ ~iff~ $[[Γ ⊢ iP]]$;
    \item[] $[[Γ ⊢ nua :≈ iN]]$ ~iff~ $[[Γ ⊢ iN]]$.
  \end{itemize}
\end{definition}


\begin{definition}[Well-formed Constraint]
  We say that a constraint is well-formed in a
  subtyping context $[[Θ]]$ if all its entries are well-formed in
  the corresponding elements of $[[Θ]]$.
  More formally, 
  $[[Θ ⊢ SC]]$ holds iff for every $[[scE]] \in $ $[[SC]]$,
  such that $[[scE]]$ restricts $[[α̂±]]$,
  we have $[[Θ(α̂±) ⊢ scE]]$.

  We write $[[Θ ⊢ SC : Ξ]]$ to denote
  that $[[Θ ⊢ SC]]$ and $[[dom(SC) = Ξ]]$.

  $[[Θ ⊢ UC]]$ and $[[Θ ⊢ UC : Ξ]]$ are defined analogously.
\end{definition}


\subsubsection{Constraint Satisfaction}

A constraint entry restricts a type that can be assigned to a variable.
We say that a type satisfies a constraint entry if it can be assigned
to the variable restricted by the entry.

\begin{definition}[Type Satisfying a Constraint Entry]
  \hfill\\
  \begin{multicols}{2}
  \ottdefnSATSCEN{}
  \columnbreak\\
  \ottdefnSATSCEP{}
  \end{multicols}
\end{definition}

We say that a substitution satisfies a constraint---a set of constraint 
entries if each entry is satisfied by the type assigned to the variable
by the substitution. 

\begin{definition}[Substitution Satisfying a Constraint]
  We write $[[Θ ⊢ uσ : SC]]$ to denote that
  a substitution $[[uσ]]$ satisfies a constraint $[[SC]]$ in a context $[[Θ]]$.
  It presumes that $[[Θ ⊢ SC]]$ and 
   means that for any $[[ucE]] \in [[SC]]$, if $[[ucE]]$ restricts $[[α̂±]]$,
  then $[[Θ(α̂±) ⊢ [uσ]α̂± : ucE]]$.


  Unification constraint satisfaction $[[Θ ⊢ uσ : UC]]$ 
  is defined analogously as a special case of subtyping constraint satisfaction.

\end{definition}


Notice that $[[Θ ⊢ uσ : SC]]$ does not 
imply the signature $[[Θ ⊢ uσ : dom(SC)]]$, because 
the latter also specifies $[[uσ]]$ outside of the domain $[[dom(SC)]]$
(see \cref{def:algo-subst-sig}).


\subsubsection{Constraint Merge}
\label{sec:constraint-merge}

In this section, define the least upper bound 
for constraints, which we call \emph{merge}.
Intuitively, the merge of two constraints is the least
constraint such that any substitution satisfying both constraints
satisfies the merge as well.
First, we define the merge of entries,
and then extend it to the set of entries.

\begin{definition} [Matching Entries]
  We call two unification constraint entries 
  or two subtyping constraint entries matching 
  if they are restricting the same unification variable.
\end{definition}

Two matching entries formed in the same context $[[Γ]]$ 
can be merged in the following way:
\begin{algorithm}[Merge of Matching Constraint Entries]
  \label{definition:merge-matching-entries}
   \hfill 

  \ottdefnSCME\\
\end{algorithm}



Unification constraint entries are a special case of subtyping constraint
entries. They are merged using the same algorithm 
(\cref{definition:merge-matching-entries}).
Notice that the merge of two matching unification constraint entries
is a unification constraint entry.
\begin{lemma}[Merge of Matching Unification Constraint Entries is well-defined]
  \label{lemma:merge-matching-entries-welldef}
  Suppose that $[[Γ ⊢ ucE1]]$ and $[[Γ ⊢ ucE2]]$
  are unification constraint entries. 
  Then the merge of $[[ucE1]]$ and $[[ucE2]]$ 
  $[[Γ ⊢ ucE1 & ucE2 = ucE]]$
  according to \cref{definition:merge-matching-entries},
  is a unification constraint entry.
\end{lemma}
\begin{proof}
  Since $[[ucE1]]$ and $[[ucE2]]$ are matching unification constraint entries,
  they have the shape $([[pua :≈ iP1]], [[pua :≈ iP2]])$ or
  $([[nua :≈ iN1]], [[nua :≈ iN2]])$.
  Then the merge of $[[ucE1]]$ and $[[ucE2]]$ 
  can only be defined by \ruleref{\ottdruleSCMEPEqEqLabel} or
  \ruleref{\ottdruleSCMENEqEqLabel}.
  In both cases the result, if it exists, 
  is a unification constraint entry:
  in the first case, the result has shape $[[pua :≈ iP1]]$,
  in the second case, the result has shape $[[nua :≈ iN1]]$.
\end{proof}


% Notice that in case of equivalence, the assigned types
% must be equal (i.e. alpha-equivalent) to be merged. This is because
% the unification algorithm assumes that every type is normalized,
% and hence, equivalence is alpha-equivalence 
% (\cref{corollary:nf-complete-wrt-subt-equiv,corollary:nf-sound-wrt-subt-equiv}).

\begin{algorithm}[Merge of Subtyping Constraints]
  \label{definition:merge-subtyping-constraints}
  Suppose that $[[Θ ⊢ SC1]]$ and $[[Θ ⊢ SC2]]$.
  Then $[[Θ ⊢ SC1 & SC2 = SC]]$
  defines a set such that $[[ucE]] \in [[SC]]$ iff either
  \begin{itemize}
    \item $[[ucE]] \in [[SC1]]$ and there is no matching $[[ucE']] \in [[SC2]]$; or
    \item $[[ucE]] \in [[SC2]]$ and there is no matching $[[ucE']] \in [[SC1]]$; or
    \item $[[Θ(α̂±) ⊢ ucE1 & ucE2 = ucE]]$ for some $[[ucE1]] \in [[SC1]]$ and $[[ucE2]] \in [[SC2]]$
      such that $[[ucE1]]$ matches with $[[ucE2]]$ restricting variable
      $[[α̂±]]$. 
  \end{itemize}
\end{algorithm}

Unification constraints can be considered 
as a special case of subtyping constraints,
and the merge of unification constraints
is defined as the merge of subtyping constraints.
Then it is easy to see that the merge of two 
unification constraints is a unification constraint.

\begin{lemma}[Merge of Unification Constraints is well-defined]
  Suppose that $[[Θ ⊢ UC1]]$ and $[[Θ ⊢ UC2]]$
  are unification constraints. 
  Then the merge of $[[UC1]]$ and $[[UC2]]$ 
  $[[Θ ⊢ lift UC1 & lift UC2 = lift UC]]$
  according to \cref{definition:merge-subtyping-constraints},
  is a unification constraint.
\end{lemma}
\begin{proof}
  $[[UC]]$ consists of unmatched entries of $[[UC1]]$ and $[[UC2]]$,
  which are \emph{unification} constraint entries by assumption,
  and merge of matching entries, which also are  
  \emph{unification} constraint entries by \cref{lemma:merge-matching-entries-welldef}.
\end{proof}

\Cref{lemma:merge-soundness,lemma:merge-completeness} 
show the correctness and initiality of the merge operation,
which can be expressed in the following simplified theorem:
\begin{theorempreview}[Correctness of Constraint Merge]
  A substitution $[[uσ]]$ satisfying both constraints
  $[[SC1]]$ and $[[SC2]]$ 
  if and only if it satisfies their merge.
\end{theorempreview}

The unification constraint merge satisfies the same theorem,
however, because the merge of unification constraint entries 
$[[ucE1]]$ and $[[ucE2]]$ always results in one of them, 
a stronger soundness property holds (see \cref{lemma:unif-merge-soundness}):
\begin{theorempreview}[Soundness of Unification Constraint Merge]
  If $[[Θ ⊢ UC1 & UC2 = UC]]$ then $[[UC = UC1 ∪ UC2]]$.
\end{theorempreview}

\subsection{Unification}
\label{sec:unification}

The subtyping algorithm calls the following subtask:
given two algorithmic types, we need to find the most general substitution 
for the algorithmic variables in these types, such that the resulting 
types are equivalent. This problem is known as \emph{unification}.

In our case, the unification is restricted in the following way:
first, before unifying the types, we normalize them, which 
allows us to reduce (non-trivial) equivalence to (trivial) equality;
second, we preserve invariants which guarantee that
one side of the unification is always declarative, which in fact, 
reduces the unification to the \emph{matching} problem.

The unification procedure
returns a set of minimal constraints,
that must be satisfied by a substitution
unifying the input types.

\begin{algorithm}[Unification]
  \hfill
  
  \begin{multicols}{2}
  \ottdefnUNUnif{}
  \columnbreak\\
  \ottdefnUPUnif{}
  \end{multicols}
\end{algorithm}


\subsection{Least Upper Bound}
\label{sec:lub}
\ottdefnsLUB

\subsection{Antiunification}
\label{sec:antiunification}
\ottdefnsAU


\section{Declarative Typing}
 
\subsection{Grammar}

\bigskip
\ottgrammartabular{
  \ottv\ottinterrule
  \ottc\ottinterrule
}

\subsection{Declarative Type Inference}
\ottdefnsDT


\section{Algorithmic Typing}

\subsection{Algorithmic Type Inference}
\ottdefnsAT

\subsection{Singularity}
\ottdefnsSING


\section{Properties of the Declarative Type System}

\subsection{Type Well-formedness}
\input{../_build/_gen/tex/wf-lemmas.tex}

\subsection{Substitution}
\input{../_build/_gen/tex/subst-lemmas.tex}

\subsection{Declarative Subtyping}
\input{../_build/_gen/tex/decl-subtyping-lemmas.tex}

\subsection{Equivalence}
\label{sec:decl-equiv-lemmas}
\input{../_build/_gen/tex/equiv-lemmas.tex}

\subsection{Variable Ordering}
\input{../_build/_gen/tex/ord-lemmas.tex}


\subsection{Normaliztaion}
\input{../_build/_gen/tex/norm-lemmas.tex}



\section{Properties of the Algorithmic Type System}

\subsection{Algorithmic Type Well-formedness}
\input{../_build/_gen/tex/wf-algo-lemmas.tex}

\subsection{Substitution}
\input{../_build/_gen/tex/subst-algo-lemmas.tex}

\subsection{Normalization}
\input{../_build/_gen/tex/norm-alg-lemmas.tex}

\subsection{Equivalence}
\input{../_build/_gen/tex/equiv-alg-lemmas.tex}

\subsection{Unification Constraint Merge}
\input{../_build/_gen/tex/unif-constraint-merge-lemmas.tex}

\subsection{Unification}
\input{../_build/_gen/tex/unification-lemmas.tex}\

\subsection{Anti-unification}
\input{../_build/_gen/tex/au-lemmas.tex}

\subsection{Upper Bounds}
\input{../_build/_gen/tex/lub-lemmas.tex}

\subsection{Upgrade}
\input{../_build/_gen/tex/upgrade-lemmas.tex}

\subsection{Constraint Satisfaction}
\input{../_build/_gen/tex/constraint-sat-lemmas.tex}

\subsection{Positive Subtyping}
\input{../_build/_gen/tex/alg-pos-subtyping-lemmas.tex}

\subsection{Subtyping Constraint Merge}
\input{../_build/_gen/tex/constraint-merge-lemmas.tex}

\subsection{Negative Subtyping}
\input{../_build/_gen/tex/alg-neg-subtyping-lemmas.tex}




\section{Properties of the Declarative Typing}
\input{../_build/_gen/tex/decl-typing-lemmas.tex}




\section{Properties of the Algorithmic Typing}

\subsection{Singularity}
\input{../_build/_gen/tex/singularity-lemmas.tex}

\subsection{Correctness of the Typing Algorithm}
\input{../_build/_gen/tex/alg-typing-lemmas.tex}

\printbibliography

\end{document}
