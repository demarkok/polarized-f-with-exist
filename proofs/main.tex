\UseRawInputEncoding
% vim: ft=tex
\documentclass[a4,natbib=false]{article}
\usepackage[a4paper, total={8in, 10in}]{geometry}
\usepackage{hyperref}
\usepackage{mathpartir}


\input{prelude.tex}


\input{../_build/_gen/included.tex}




% \renewcommand{\ottdruleEOneNVarName}[0]{ Hello \def\@currentlabelname{FOO} \phantomsection  }
% \newcommand{\ottdrulename}[1]{\textsc{#1}}

% \renewcommand{\ottdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}%
%   }\ruleLabel{#4}{#4}}

% \renewcommand{\ottdrule}[4][]{%
%   {\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}}%
%   \mpr@label{\textsc{#1}}%
% }
% \DeclareDocumentCommand \redrule {m m o}{%
%   \inferrule*[vcenter,left={#3:}]{}{#1 \tred #2}
%   \mpr@label{\textsc{#3}}
% }

% \renewcommand{\ottdrulename}[2][#1]{\textsc{#1} \label{}}


% \renewcommand{\ottdruleEOneNVarName}[0]{foo }

% \makeatletter
% \renewcommand{\ottdruleEOneNVar}[1]{\ottdrule[#1]{%
%   }{
%     % \protected@edef\@currentlabelname{foo}
%     \def\@currentlabelname{foo}%
%     \phantomsection
%     \label{boo}
%     \alpha ^{-}   \eqEOne   \alpha ^{-}
%   }{%
%     {\ottdruleEOneNVarName}{}%
%   } }
% \makeatother


\newcommand{\depth}[1]{\mathsf{depth}(#1)}

\newcommand{\ruleref}[1]{Rule \nameref{#1}}

% ord varset in uN = varset'

\renewcommand{\ottdruleONVarInName}[0]{(Var$_{\in}^-$)}
\renewcommand{\ottdruleONVarNInName}[0]{(Var$_{\notin}^-$)}
\renewcommand{\ottdruleONUVarName}[0]{(UVar$^-$)}
\renewcommand{\ottdruleOShiftUName}[0]{($\uparrow$)}
\renewcommand{\ottdruleOArrowName}[0]{($\rightarrow$)}
\renewcommand{\ottdruleOForallName}[0]{($\forall$)}


% ord varset in uP = varset'

\renewcommand{\ottdruleOPVarInName}[0]{(Var$_{\in}^+$)}
\renewcommand{\ottdruleOPVarNInName}[0]{(Var$_{\notin}^+$)}
\renewcommand{\ottdruleOPUVarName}[0]{(UVar$^+$)}
\renewcommand{\ottdruleOShiftDName}[0]{($\downarrow$)}
\renewcommand{\ottdruleOExistsName}[0]{($\exists$)}


% nf(N) = M
\renewcommand{\ottdruleNrmNVarName}[0]{(Var$^-$)}
\renewcommand{\ottdruleNrmNUVarName}[0]{(UVar$^-$)}
\renewcommand{\ottdruleNrmShiftUName}[0]{($\uparrow$)}
\renewcommand{\ottdruleNrmArrowName}[0]{($\rightarrow$)}
\renewcommand{\ottdruleNrmForallName}[0]{($\forall$)}

% nf(P) = Q
\renewcommand{\ottdruleNrmPVarName}[0]{(Var$^+$)}
\renewcommand{\ottdruleNrmPUVarName}[0]{(UVar$^+$)}
\renewcommand{\ottdruleNrmShiftDName}[0]{($\downarrow$)}
\renewcommand{\ottdruleNrmExistsName}[0]{($\exists$)}


% N ≈ M

\renewcommand{\ottdruleEOneNVarName}[0]{(Var$^-$$^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftUName}[0]{($\uparrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneArrowName}[0]{($\rightarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneForallName}[0]{($\forall^{\eqEOne}$)}

% P ≈ Q
\renewcommand{\ottdruleEOnePVarName}[0]{(Var$^+$$^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftDName}[0]{($\downarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneExistsName}[0]{($\exists^{\eqEOne}$)}


% G ⊢ N ≤1 M

\renewcommand{\ottdruleDOneNVarName}[0]{(Var$^-$$^{\subDOne}$)}
\renewcommand{\ottdruleDOneShiftUName}[0]{($\uparrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneArrowName}[0]{($\rightarrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneForallName}[0]{($\forall^{\subDOne}$)}

% G ⊢ P ≥1 Q
\renewcommand{\ottdruleDOnePVarName}[0]{(Var$^+$$^{\supDOne}$)}
\renewcommand{\ottdruleDOneShiftDName}[0]{($\downarrow^{\supDOne}$)}
\renewcommand{\ottdruleDOneExistsName}[0]{($\exists^{\supDOne}$)}


% G ⊢ N ≈1 M
\renewcommand{\ottdruleDOneNDefName}[0]{($\eqDOne^{-}$)}

% G ⊢ P ≈1 Q
\renewcommand{\ottdruleDOnePDefName}[0]{($\eqDOne^{+}$)}



% G ⊨ iP1 ∨ iP2 = iQ
\renewcommand{\ottdruleLUBVarName}[0]{(Var$^{\vee}$)}
\renewcommand{\ottdruleLUBShiftName}[0]{($\downarrow^{\vee}$)}
\renewcommand{\ottdruleLUBExistsName}[0]{($\exists^{\vee}$)}
\renewcommand{\ottdruleLUBUpgradeName}[0]{(Upg)}


% G ; Θ ⊨ uN ≤ iM ⫤ us
\renewcommand{\ottdruleANVarName}[0]{(Var$^-$$^{\subA}$)}
\renewcommand{\ottdruleAShiftUName}[0]{($\uparrow^{\subA}$)}
\renewcommand{\ottdruleAArrowName}[0]{($\rightarrow^{\subA}$)}
\renewcommand{\ottdruleAForallName}[0]{($\forall^{\subA}$)}

% G ; Θ ⊨ iP ≥ uQ ⫤ us
\renewcommand{\ottdruleAPVarName}[0]{(Var$^+$$^{\supA}$)}
\renewcommand{\ottdruleAShiftDName}[0]{($\downarrow^{\supA}$)}
\renewcommand{\ottdruleAExistsName}[0]{($\exists^{\supA}$)}
\renewcommand{\ottdruleAPUVarName}[0]{(UVar$^{\supA}$)}


% Γ ⊢ scE1 & scE2 = scE3 :: :: E :: 'E'
\renewcommand{\ottdruleSCMESupSupName}[0]{$([[≥]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSCMEEqSupName}[0]{$([[≈]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSCMESupEqName}[0]{$([[≥]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSCMEPEqEqName}[0]{$([[≈]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSCMENEqEqName}[0]{$([[≈]]\&^{-}[[≈]])$}

% Γ ; Θ ⊨ uN ≈u iM ⫤ UC 
\renewcommand{\ottdruleUNVarName}[0]{(Var$^{-[[≈u]]}$)}
\renewcommand{\ottdruleUShiftUName}[0]{($\uparrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUArrowName}[0]{($\rightarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUForallName}[0]{($\forall^{[[≈u]]}$)}
\renewcommand{\ottdruleUNUVarName}[0]{(UVar$^{-[[≈u]]}$)}

% Γ ; Θ ⊨ uP ≈u iQ ⫤ UC 
\renewcommand{\ottdruleUPVarName}[0]{(Var$^{+[[≈u]]}$)}
\renewcommand{\ottdruleUShiftDName}[0]{($\downarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUExistsName}[0]{($\exists^{[[≈u]]}$)}
\renewcommand{\ottdruleUPUVarName}[0]{(UVar$^{+[[≈u]]}$)}

% G ⊨ iP1 ≈au iP2 ⫤ ( Ξ , uQ , aus1 , aus2 )
\renewcommand{\ottdruleAUPVarName}[0]{(Var$^{+[[≈au]]}$)}
\renewcommand{\ottdruleAUShiftDName}[0]{($\downarrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUExistsName}[0]{($\exists^{[[≈au]]}$)}

% G ⊨ iN1 ≈au iN2 ⫤ ( Ξ , uM , aus1 , aus2 )
\renewcommand{\ottdruleAUNVarName}[0]{(Var$^{-[[≈au]]}$)}
\renewcommand{\ottdruleAUShiftUName}[0]{($\uparrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUForallName}[0]{($\forall^{[[≈au]]}$)}
\renewcommand{\ottdruleAUArrowName}[0]{($\rightarrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUAUName}[0]{(AU$^{-}$)}



\begin{document}

\tableofcontents


\section{The Vanilla System}



First, we present the top-level system, which is easy to understand.

\subsection{Grammar}
\ottgrammartabular{
  \ottP\ottinterrule
  \ottN\ottinterrule
  \ottv\ottinterrule
  \ottc\ottinterrule
}

\subsection{Declarative Typing}
\ottdefnsDT

\subsection{Declarative Subtyping}
\ottdefnsDZero

\section{Multi-Quantified System}
\subsection{Grammar}
\ottgrammartabular{
  \ottiP\ottinterrule
  \ottiN\ottinterrule
}
\subsection{Declarative Multiquantified Subtyping}
\ottdefnsDOne

\subsection{Declarative Equivalence}
\ottdefnsEOne



\section{Algorithm}

\subsection{Normalization}

\subsubsection{Ordering}
\ottdefnsOrder

\subsubsection{Quantifier Normalization}
\ottdefnsNrm

\subsection{Singularity}
\ottdefnsSING

% \subsection{Algorithmic Equivalence}
% \ottdefnsEOneA

\subsection{Unification}
\ottdefnsU

\subsection{Algorithmic Subtyping}
\ottdefnsA



\subsection{Constraint Merge}

Unification and subtyping constraints is are by a list of constraint entries.
Each entry restricts an unification variable in two possible ways: either
stating that it must be equivalent to a certain type ($[[pua :≈ iP]]$ or $[[nua
:≈ iN]]$) or that it must be a (positive) supertype of a certain type ($[[pua :≥ iP]]$).

\begin{definition} [Matching Entries]
  We call two entries matching if they are restricting the same unification variable.
\end{definition}

Two matching entries can be merged in the following way:
\begin{definition} \hfill \\
\ottdefnSCME\\
\end{definition}
% Notice that in case of equivalence, the assigned types
% must be equal (i.e. alpha-equivalent) to be merged. This is because
% the unification algorithm assumes that every type is normalized,
% and hence, equivalence is alpha-equivalence 
% (\cref{corollary:nf-complete-wrt-subt-equiv,corollary:nf-sound-wrt-subt-equiv}).

To merge two constraints, we merge each pair of
matching entries, and unite the results.
\ilyam{add contexts}
\begin{definition}
  $\begin{aligned}[t] [[SC1 & SC2]] &= 
    \{ [[scE1 & scE2]] \mid [[scE1]] \in [[SC1]], [[scE2]]  \in [[SC2]], \text{s.t. } [[scE1]] \text{ matches with } [[scE2]] \}\\
    &\cup 
    \{ [[scE1]] \mid [[scE1]] \in [[SC1]], \text{ s.t. } \forall [[scE2]]  \in [[SC2]], [[scE1]] \text{ does not match with } [[scE2]] \}\\
    &\cup 
    \{ [[scE2]] \mid [[scE2]] \in [[SC2]], \text{ s.t. } \forall [[scE1]]  \in [[SC1]], [[scE1]] \text{ does not match with } [[scE2]] \}\\
   \end{aligned}$
\end{definition}

\subsection{Constraint Satisfaction}
\ottdefnsSATSCE

\subsection{Least Upper Bound}
\ottdefnsLUB

\subsection{Antiunification}
\ottdefnsAU

\subsection{Typing}
\ottdefnsAT

\section{Proofs}

\subsection{Substitution}
\input{../_build/_gen/tex/subst-lemmas.tex}

\subsection{Declarative Subtyping}
\input{../_build/_gen/tex/decl-subtyping-lemmas.tex}

\subsection{Type well-formedness}
\input{../_build/_gen/tex/wf-lemmas.tex}

\subsection{Overview}
\input{../_build/_gen/tex/lemmas-overview.tex}

\subsection{Variable Ordering}
\input{../_build/_gen/tex/ord-lemmas.tex}

\subsection{Normaliztaion}
\input{../_build/_gen/tex/norm-lemmas.tex}

\subsection{Equivalence}
\input{../_build/_gen/tex/equiv-lemmas.tex}

\subsection{Unification Constraint Merge}
\input{../_build/_gen/tex/unif-constraint-merge-lemmas.tex}

\subsection{Unification}
\input{../_build/_gen/tex/unification-lemmas.tex}\

\subsection{Anti-unification}
\input{../_build/_gen/tex/anti-unification-lemmas.tex}

\subsection{Upper Bounds}
\input{../_build/_gen/tex/lub-lemmas.tex}

\subsection{Upgrade}
\input{../_build/_gen/tex/upgrade-lemmas.tex}

\subsection{Positive Subtyping}
\input{../_build/_gen/tex/alg-pos-subtyping-lemmas.tex}

\subsection{Subtyping Constraint Merge}
\input{../_build/_gen/tex/constraint-merge-lemmas.tex}

\subsection{Constraint Satisfaction}
\input{../_build/_gen/tex/constraint-sat-lemmas.tex}

\subsection{Negative Subtyping}
\input{../_build/_gen/tex/alg-neg-subtyping-lemmas.tex}

\subsection{Singularity}
\input{../_build/_gen/tex/singularity-lemmas.tex}

\subsection{Declarative Typing}
\input{../_build/_gen/tex/decl-typing-lemmas.tex}

\subsection{Algorithmic Typing}
\input{../_build/_gen/tex/alg-typing-lemmas.tex}

\end{document}
