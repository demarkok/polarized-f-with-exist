\UseRawInputEncoding
% vim: ft=tex
\documentclass[a4,natbib=false]{article}
\usepackage[a4paper, total={8in, 10in}]{geometry}
\usepackage{hyperref}
\usepackage{mathpartir}


\input{prelude.tex}


\input{../_build/_gen/included.tex}




% \renewcommand{\ottdruleEOneNVarName}[0]{ Hello \def\@currentlabelname{FOO} \phantomsection  }
% \newcommand{\ottdrulename}[1]{\textsc{#1}}

% \renewcommand{\ottdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}%
%   }\ruleLabel{#4}{#4}}

% \renewcommand{\ottdrule}[4][]{%
%   {\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}}%
%   \mpr@label{\textsc{#1}}%
% }
% \DeclareDocumentCommand \redrule {m m o}{%
%   \inferrule*[vcenter,left={#3:}]{}{#1 \tred #2}
%   \mpr@label{\textsc{#3}}
% }

% \renewcommand{\ottdrulename}[2][#1]{\textsc{#1} \label{}}


% \renewcommand{\ottdruleEOneNVarName}[0]{foo }

% \makeatletter
% \renewcommand{\ottdruleEOneNVar}[1]{\ottdrule[#1]{%
%   }{
%     % \protected@edef\@currentlabelname{foo}
%     \def\@currentlabelname{foo}%
%     \phantomsection
%     \label{boo}
%     \alpha ^{-}   \eqEOne   \alpha ^{-}
%   }{%
%     {\ottdruleEOneNVarName}{}%
%   } }
% \makeatother

\newcommand{\depth}[1]{\ensuremath{\mathsf{depth}(#1)}}
\newcommand{\size}[1]{\ensuremath{\mathsf{size}(#1)}}

\newcommand{\ruleref}[1]{Rule \nameref{#1}}

% ord varset in uN = varset'

\renewcommand{\ottdruleONVarInName}[0]{(Var$_{-\in}^{\text{Ord}}$)}
\renewcommand{\ottdruleONVarNInName}[0]{(Var$_{-\notin}^{\text{Ord}}$)}
\renewcommand{\ottdruleONUVarName}[0]{(UVar$_{-} ^{\text{Ord}}$)}
\renewcommand{\ottdruleOShiftUName}[0]{($\uparrow^{\text{Ord}}$)}
\renewcommand{\ottdruleOArrowName}[0]{($\rightarrow^{\text{Ord}}$)}
\renewcommand{\ottdruleOForallName}[0]{($\forall^{\text{Ord}}$)}


% ord varset in uP = varset'

\renewcommand{\ottdruleOPVarInName}[0]{(Var$_{+\in}^{\text{Ord}}$)}
\renewcommand{\ottdruleOPVarNInName}[0]{(Var$_{+\notin}^{\text{Ord}}$)}
\renewcommand{\ottdruleOPUVarName}[0]{(UVar$_{+}^{\text{Ord}}$)}
\renewcommand{\ottdruleOShiftDName}[0]{($\downarrow^{\text{Ord}}$)}
\renewcommand{\ottdruleOExistsName}[0]{($\exists^{\text{Ord}}$)}


% nf(N) = M
\renewcommand{\ottdruleNrmNVarName}[0]{(Var$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmNUVarName}[0]{(UVar$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmShiftUName}[0]{($\uparrow^{\text{nf}}$)}
\renewcommand{\ottdruleNrmArrowName}[0]{($\rightarrow^{\text{nf}}$)}
\renewcommand{\ottdruleNrmForallName}[0]{($\forall^{\text{nf}}$)}

% nf(P) = Q
\renewcommand{\ottdruleNrmPVarName}[0]{(Var$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmPUVarName}[0]{(UVar$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmShiftDName}[0]{($\downarrow^{\text{nf}}$)}
\renewcommand{\ottdruleNrmExistsName}[0]{($\exists^{\text{nf}}$)}


% N ≈ M

\renewcommand{\ottdruleEOneNVarName}[0]{(Var$_-^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftUName}[0]{($\uparrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneArrowName}[0]{($\rightarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneForallName}[0]{($\forall^{\eqEOne}$)}

% P ≈ Q
\renewcommand{\ottdruleEOnePVarName}[0]{(Var$_+^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftDName}[0]{($\downarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneExistsName}[0]{($\exists^{\eqEOne}$)}


% G ⊢ N ≤1 M

\renewcommand{\ottdruleDOneNVarName}[0]{(Var$_-^{\subDOne}$)}
\renewcommand{\ottdruleDOneShiftUName}[0]{($\uparrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneArrowName}[0]{($\rightarrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneForallName}[0]{($\forall^{\subDOne}$)}

% G ⊢ P ≥1 Q
\renewcommand{\ottdruleDOnePVarName}[0]{(Var$_+^{\supDOne}$)}
\renewcommand{\ottdruleDOneShiftDName}[0]{($\downarrow^{\supDOne}$)}
\renewcommand{\ottdruleDOneExistsName}[0]{($\exists^{\supDOne}$)}


% G ⊢ N ≈1 M
\renewcommand{\ottdruleDOneNDefName}[0]{($\eqDOne_{-}$)}

% G ⊢ P ≈1 Q
\renewcommand{\ottdruleDOnePDefName}[0]{($\eqDOne_{+}$)}



% G ⊨ iP1 ∨ iP2 = iQ
\renewcommand{\ottdruleLUBVarName}[0]{(Var$^{\vee}$)}
\renewcommand{\ottdruleLUBShiftName}[0]{($\downarrow^{\vee}$)}
\renewcommand{\ottdruleLUBExistsName}[0]{($\exists^{\vee}$)}
\renewcommand{\ottdruleLUBUpgradeName}[0]{(Upg)}


% G ; Θ ⊨ uN ≤ iM ⫤ us
\renewcommand{\ottdruleANVarName}[0]{(Var$_-^{\subA}$)}
\renewcommand{\ottdruleAShiftUName}[0]{($\uparrow^{\subA}$)}
\renewcommand{\ottdruleAArrowName}[0]{($\rightarrow^{\subA}$)}
\renewcommand{\ottdruleAForallName}[0]{($\forall^{\subA}$)}

% G ; Θ ⊨ iP ≥ uQ ⫤ us
\renewcommand{\ottdruleAPVarName}[0]{(Var$_+^{\supA}$)}
\renewcommand{\ottdruleAShiftDName}[0]{($\downarrow^{\supA}$)}
\renewcommand{\ottdruleAExistsName}[0]{($\exists^{\supA}$)}
\renewcommand{\ottdruleAPUVarName}[0]{(UVar$^{\supA}$)}


% Γ ⊢ scE1 & scE2 = scE3 :: :: E :: 'E'
\renewcommand{\ottdruleSCMESupSupName}[0]{$([[≥]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSCMEEqSupName}[0]{$([[≈]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSCMESupEqName}[0]{$([[≥]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSCMEPEqEqName}[0]{$([[≈]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSCMENEqEqName}[0]{$([[≈]]\&^{-}[[≈]])$}

% Γ ; Θ ⊨ uN ≈u iM ⫤ UC 
\renewcommand{\ottdruleUNVarName}[0]{(Var$_{-}^{[[≈u]]}$)}
\renewcommand{\ottdruleUShiftUName}[0]{($\uparrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUArrowName}[0]{($\rightarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUForallName}[0]{($\forall^{[[≈u]]}$)}
\renewcommand{\ottdruleUNUVarName}[0]{(UVar$_{-}^{[[≈u]]}$)}

% Γ ; Θ ⊨ uP ≈u iQ ⫤ UC 
\renewcommand{\ottdruleUPVarName}[0]{(Var$_{+}^{[[≈u]]}$)}
\renewcommand{\ottdruleUShiftDName}[0]{($\downarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUExistsName}[0]{($\exists^{[[≈u]]}$)}
\renewcommand{\ottdruleUPUVarName}[0]{(UVar$_{+}^{[[≈u]]}$)}

% G ⊨ iP1 ≈au iP2 ⫤ ( Ξ , uQ , aus1 , aus2 )
\renewcommand{\ottdruleAUPVarName}[0]{(Var$_{+}^{[[≈au]]}$)}
\renewcommand{\ottdruleAUShiftDName}[0]{($\downarrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUExistsName}[0]{($\exists^{[[≈au]]}$)}

% G ⊨ iN1 ≈au iN2 ⫤ ( Ξ , uM , aus1 , aus2 )
\renewcommand{\ottdruleAUNVarName}[0]{(Var$_{-}^{[[≈au]]}$)}
\renewcommand{\ottdruleAUShiftUName}[0]{($\uparrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUForallName}[0]{($\forall^{[[≈au]]}$)}
\renewcommand{\ottdruleAUArrowName}[0]{($\rightarrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUAUName}[0]{(AU$_{-}$)}

% Γ ⊢ iN 
\renewcommand{\ottdruleWFTNVarName}[0]{(Var$_{-}^{\text{WF}}$)}
\renewcommand{\ottdruleWFTShiftUName}[0]{($\uparrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFTArrowName}[0]{($\rightarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFTForallName}[0]{($\forall^{\text{WF}}$)}

% Γ ⊢ iP
\renewcommand{\ottdruleWFTPVarName}[0]{(Var$_{+}^{\text{WF}}$)}
\renewcommand{\ottdruleWFTShiftDName}[0]{($\downarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFTExistsName}[0]{($\exists^{\text{WF}}$)}

% Γ ; Ξ ⊢ uN
\renewcommand{\ottdruleWFATNVarName}[0]{(Var$_{-}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATNUVarName}[0]{(UVar$_{-}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATShiftUName}[0]{($\uparrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFATArrowName}[0]{($\rightarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFATForallName}[0]{($\forall^{\text{WF}}$)}

% Γ ; Ξ ⊢ uP
\renewcommand{\ottdruleWFATPVarName}[0]{(Var$_{+}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATPUVarName}[0]{(UVar$_{+}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATShiftDName}[0]{($\downarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFATExistsName}[0]{($\exists^{\text{WF}}$)}

% Γ ⊢ iP : scE
\renewcommand{\ottdruleSATSCESupName}[0]{($[[:≥]]_{+}^\text{sat}$)}
\renewcommand{\ottdruleSATSCEPEqName}[0]{($[[:≈]]_{+}^\text{sat}$)}

% Γ ⊢ iN : scE
\renewcommand{\ottdruleSATSCENEqName}[0]{($[[:≈]]_{-}^\text{sat}$)}

% Γ ; Φ ⊢ v : iP 
\renewcommand{\ottdruleDTVarName}[0]{(Var$^{\text{inf}}$)}
\renewcommand{\ottdruleDTThunkName}[0]{($\{\}^{\text{inf}}$)}
\renewcommand{\ottdruleDTPAnnotName}[0]{(ann$_+^{\text{inf}}$)}
\renewcommand{\ottdruleDTPEquivName}[0]{($[[≈]]_+^{\text{inf}}$)}

% Γ ; Φ ⊢ c : iN 
\renewcommand{\ottdruleDTtLamName}[0]{($\lambda^{\text{inf}}$)}
\renewcommand{\ottdruleDTTLamName}[0]{($\Lambda^{\text{inf}}$)}
\renewcommand{\ottdruleDTReturnName}[0]{(ret$^{\text{inf}}$)}
\renewcommand{\ottdruleDTVarLetName}[0]{(let$^{\text{inf}}$)}
\renewcommand{\ottdruleDTAppLetName}[0]{(let$_@^{\text{inf}}$)}
\renewcommand{\ottdruleDTAppLetAnnName}[0]{(let$_{:@}^{\text{inf}}$)}
\renewcommand{\ottdruleDTUnpackName}[0]{(let$_{\exists}^{\text{inf}}$)}
\renewcommand{\ottdruleDTNAnnotName}[0]{(ann$_-^{\text{inf}}$)}
\renewcommand{\ottdruleDTNEquivName}[0]{($[[≈]]_-^{\text{inf}}$)}

% Γ ; Φ ⊢ iN ● args ⇒> iM 
\renewcommand{\ottdruleDTEmptyAppName}[0]{($\emptyset_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleDTArrowAppName}[0]{($\rightarrow_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleDTForallAppName}[0]{($\forall_{[[●]][[⇒>]]}^{\text{inf}}$)}



% Γ ; Φ ⊨ v : iP  
\renewcommand{\ottdruleATVarName}[0]{(Var$^{\text{inf}}$)}
\renewcommand{\ottdruleATThunkName}[0]{($\{\}^{\text{inf}}$)}
\renewcommand{\ottdruleATPAnnotName}[0]{(ann$_+^{\text{inf}}$)}

% Γ ; Φ ⊨ c : iN 
\renewcommand{\ottdruleATtLamName}[0]{($\lambda^{\text{inf}}$)}
\renewcommand{\ottdruleATTLamName}[0]{($\Lambda^{\text{inf}}$)}
\renewcommand{\ottdruleATReturnName}[0]{(ret$^{\text{inf}}$)}
\renewcommand{\ottdruleATVarLetName}[0]{(let$^{\text{inf}}$)}
\renewcommand{\ottdruleATAppLetName}[0]{(let$_@^{\text{inf}}$)}
\renewcommand{\ottdruleATAppLetAnnName}[0]{(let$_{:@}^{\text{inf}}$)}
\renewcommand{\ottdruleATUnpackName}[0]{(let$_{\exists}^{\text{inf}}$)}
\renewcommand{\ottdruleATNAnnotName}[0]{(ann$_-^{\text{inf}}$)}

% Γ ; Φ ; Θ1 ⊨ uN ● args ⇒> uM ⫤ Θ2 ; SC 
\renewcommand{\ottdruleATEmptyAppName}[0]{($\emptyset_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleATArrowAppName}[0]{($\rightarrow_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleATForallAppName}[0]{($\forall_{[[●]][[⇒>]]}^{\text{inf}}$)}

% scE1 singular with iP
\renewcommand{\ottdruleSINGPEqName}[0]{($[[≈]]_{+}^{\text{sing}}$)}
\renewcommand{\ottdruleSINGSupVarName}[0]{($[[:≥]]\alpha^{\text{sing}}$)}
\renewcommand{\ottdruleSINGSupShiftName}[0]{($[[:≥]][[↓]]^{\text{sing}}$)}

% scE1 singular with iN
\renewcommand{\ottdruleSINGNEqName}[0]{($[[≈]]_{-}^{\text{sing}}$)}

\begin{document}

\tableofcontents

\newpage

\section{Declarative Type Systems}

\subsection{Grammar}
We assume that there is an infinite set of positive and 
negative \emph{type} variables. Positive type variables are denoted as 
$[[α⁺]]$, $[[β⁺]]$, $[[γ⁺]]$, etc.
Negative type variables are denoted as $[[α⁻]]$, $[[β⁻]]$, $[[γ⁻]]$, etc.
We assume there is an infinite set of \emph{term} variables,
which are denoted as $[[x]]$, $[[y]]$, $[[z]]$, etc.
A list of objects (variables, types or terms) is denoted by
an overline arrow. For instance, $[[pas]]$ is a list of positive type variables, 
$[[nbs]]$ is a list of negative type variables, 
$[[args]]$ is a list of values, which are arguments of a function.
$[[fv(iP)]]$ and $[[fv(iN)]]$ denote the set of free variables 
in a type $[[iP]]$ and $[[iN]]$, respectively.


\bigskip

\ottgrammartabular{
  \ottiP\ottinterrule
  \ottiN\ottinterrule
}

\subsection{Equalities}
For simplicity, assume alpha-equivalent terms equal. 
This way, we assume that substitutions do not capture bound variables.
Besides, we equate
$[[∀pas.∀pbs.iN]]$ with $[[∀pas,pbs.iN]]$, 
as well as $[[∃nas.∃nbs.iP]]$ with $[[∃nas,nbs.iP]]$,
and lift these equations transitively and congruently 
to the whole system.

\subsection{Contexts and Well-formedness}

\begin{definition}[Declarative Type Context]
  \hfill \\
  Declarative type context $[[Γ]]$ is represented by a set of 
  type variables. The concatenation $[[Γ1, Γ2]]$ means the 
  union of two contexts $[[Γ1 ∪ Γ2]]$.
\end{definition}

$[[Γ ⊢ iP]]$ and $[[Γ ⊢ iN]]$ denote that the type is well-formed in the context $[[Γ]]$,
which, in fact, means that each free type variable of the type is contained in $[[Γ]]$
(it will be shown later in \cref{lemma:wf-soundness,lemma:wf-ctxt-equiv}).

\hfill\\
\ottdefnsWFT


\subsection{Substitutions}

\begin{definition}[Substitution]
  Substitutions (denoted as $[[σ]]$) 
  are represented by total functions form variables to types, preserving the polarity. 
\end{definition}

\begin{definition}[Substitution Application]
  Substitution application (denoted as $[[ [σ]iP ]]$ or $[[ [σ]iN ]]$) 
  is defined congruently as follows:
  \begin{itemize}
    \item $[[ [σ]α⁺ ]] = [[σ]] ([[α⁺]])$;
    \item $[[ [σ]α⁻ ]] = [[σ]] ([[α⁻]])$;
    \item $[[ [σ]↓iN ]] = [[↓[σ]iN]]$;
    \item $[[ [σ]↑iP ]] = [[↑[σ]iP]]$;
    \item $[[ [σ]∃nas.iQ ]] = [[∃nas.[σ]iQ]]$, 
    \item $[[ [σ]∀pas.iN ]] = [[∀pas.[σ]iN]]$(here we assume that $[[nas]]$ and $[[pas]]$ are lists of fresh variables, 
      that is the variable capture never happens);
    \item $[[ [σ](iP → iN) ]] = [[ [σ]iP → [σ]iN ]]$.
  \end{itemize}
\end{definition}

\begin{definition}[Substitution Signature]
  The signature $[[Γ' ⊢ σ : Γ]]$ means that
  \begin{enumerate}
    \item for any $[[α± ∊ Γ]], [[ Γ' ⊢ [σ]α± ]]$; and
    \item for any $[[α± ∉ Γ']], [[ [σ]α± = α± ]]$.
  \end{enumerate}
\end{definition}

A substitution can be restricted to a set of variables. 
The restricted substitution is define as expected. 
\begin{definition}[Subsitution Restriction]
  The specification $[[σ  | varset]]$ is defined as
  a function such that 
  \begin{enumerate}
    \item $[[σ|varset]]([[α± ]]) = [[σ]]([[α± ]])$, if $[[α± ]] \in [[varset]]$; and
    \item $[[σ|varset]]([[α± ]]) = [[α± ]]$, if $[[α± ]] \notin [[varset]]$.
  \end{enumerate}
\end{definition}

Two substitutions can be composed in two ways:
$[[σ2 ○ σ1]]$ corresponds to a consecutive application of $[[σ1]]$ and $[[σ2]]$,
while $[[σ2 <=< σ1]]$
depends on a signature of $[[σ1]]$ and modifies $[[σ1]]$ by applying
$[[σ2]]$ to its results on the domain.
\begin{definition}[Substitution Composition]
  $[[σ2 ○ σ1]]$ is defined as a function such that
  $[[σ2 ○ σ1]]([[α± ]]) = [[σ2]]([[σ1]]([[α± ]]))$.
\end{definition}

\begin{definition}[Monadic Substitution Composition]
  Suppose that $[[Γ' ⊢ σ1 : Γ]]$.
  Then we define $[[σ2 <=< σ1]]$ as $[[(σ2 ○ σ1)|Γ]]$.
\end{definition}
Notice that the result of $[[σ2 <=< σ1]]$ depends on the 
specification of $[[σ1]]$, which is not unique. 
However, we assume that the used specification clear from the 
context of the proof. 

\begin{definition}[Equivalent Substitutions]
  The substitution equivalence judgement $[[Γ' ⊢ σ1 ≈ σ2 : Γ]]$ 
  indicates that on the domain $[[Γ]]$, 
  the result of $[[σ1]]$ and $[[σ2]]$ are equivalent in context $[[Γ']]$.
  Formally, for any $[[α± ∊ Γ]], [[ Γ' ⊢ [σ1]α± ≈ [σ2]α± ]]$.
\end{definition}

Sometimes it is convenient to construct substitution 
explicitly mapping each variable from a list (or a set)
to a type. Such substitutions are denoted as $[[iPs / pas]]$
and $[[iNs / nas]]$, where $[[iPs]]$ and $[[iNs]]$ are lists of 
the corresponding types.
\begin{definition}[Explicit Substitution]
  \hfill
  \begin{itemize}
    \item [$-$]
      Suppose that $[[nas]]$ is a list of negative type variables,
      and $[[iNs]]$ is a list of negative types of the same length 
      Then $[[iNs / nas]]$ denotes a substitution such that 
      \begin{enumerate}
        \item for $[[αi⁺ ∊ {nas}]]$, $[[ [iNs / nas] αi⁺]] = [[iNi]]$;
        \item for $[[β⁺ ∉ {nas}]]$, $[[ [iNs / nas] β⁺]] = [[β⁺]]$.
      \end{enumerate}
    \item [$+$]
      Positive explicit substitution $[[iPs / pas]]$
      is defined symmetrically.
  \end{itemize}
\end{definition}


\subsection{Declarative Subtyping}
\ottdefnsDOne

\subsection{Declarative Equivalence}
\ottdefnsEOne

\section{Algorithmic Type System}

\subsection{Grammar}

In the algorithmic system, we extend the grammar of types
by adding positive and negative \emph{algorithmic variables}
($[[α̂⁺]]$, $[[β̂⁺]]$, $[[γ̂⁺]]$, etc. and $[[α̂⁻]]$, $[[β̂⁻]]$, $[[γ̂⁻]]$, etc.).
They represent the unknown types, which will be inferred by the algorithm.
This way, we add two base cases to the grammar of 
positive and negative types, and use highlight to denote that the type
can potentially contain algorithmic variables.

 
\begin{definition}[Algorithmic Types]
  \hfill \\
\ottgrammartabular{
  \ottuP\ottinterrule
  \ottuN\ottinterrule
}
\end{definition}

\subsection{Fresh Variable Selection}
\label{sec:fresh-selection}
Both the subtyping and the type inference algorithm
rely on the ability to select fresh, unused variables.
In the inference rules, it is indicated as 
$[[{varset} are fresh]]$. 
We assume that the selection subroutine always succeeds and is 
deterministic. In other words, whenever it is called in 
an algorithmic inference rule, it returns the same result, 
uniquely determined by the input of this rule.

\subsection{Variable Algorithmization}

In several places of our algorithm, in particular, during anti-unification,
we turn a declarative type into the algorithmic one
via replacing certain type variables with fresh algorithmic variables.

\begin{definition}[Variable Algorithmization]
  Suppose that $[[nas]]$ is a list of negative type variables
  and $[[nuas]]$ is a list of negative algorithmic variables of the same length. 
  Then $[[ nuas/nas ]]$ is a substitution-like procedure turning each $[[αi⁻ ∊ {nas}]]$ 
  into $[[αî⁻ ∊ {nuas}]]$.
\end{definition}

Conversely, we can turn algorithmic type variables
into declarative type variables via \emph{dealgorithmization}.

\begin{definition}[Variable Dealgorithmization]
  Suppose that $[[nuas]]$ is a list of negative algorithmic variables
  and $[[nas]]$ is a list of negative type variables of the same length. 
  Then $[[ nas/nuas ]]$ is a substitution-like procedure turning each
  $[[αî⁻ ∊ {nuas}]]$ into $[[αi⁻ ∊ {nas}]]$.
\end{definition}


\subsection{Contexts and Well-formedness}

\begin{definition}[Algorithmic Type Context]
  \hfill \\
  Algorithmic type context $[[Ξ]]$ is represented by a set of 
  \emph{algorithmic} type variables ($[[α̂⁺]]$, $[[α̂⁻]]$, $[[β̂⁺]]$, \dots).
  The concatenation $[[Ξ1, Ξ2]]$ means the union of two contexts $[[Ξ1 ∪ Ξ2]]$.
\end{definition}

$[[Γ ; Ξ ⊢ uP]]$ and $[[Γ ; Ξ ⊢ uN]]$ are used to denote
that the algorithmic type is well-formed in the contexts
$[[Γ]]$ and $[[Ξ]]$, which means that each algorithmic variable
of the type is contained in $[[Ξ]]$, and each free declarative type variable
of the type is contained in $[[Γ]]$.

\hfill\\
\ottdefnsWFAT

Algorithmic Type Context are used in the unification algorithm.
In the subtyping algorithm, 
the context needs to remember additional information.
In the subtyping context, each algorithmic variable is associated with a
context it must be instantiated in 
(i.e. the context in which the type replacing the variable must be well-formed).
This association is represented by \emph{algorithmic subtyping context} $[[Θ]]$.
\begin{definition}[Algorithmic Subtyping Context]
  \hfill \\
  Algorithmic Subtyping Context $[[Θ]]$ is represented by a set of 
  entries of form $[[ α̂⁺[Γ] ]]$ and $[[ α̂⁻[Γ] ]]$,
  where $[[α̂⁺]]$ and $[[α̂⁻]]$ are algorithmic variables,
  and $[[Γ]]$ is a context in which they must be instantiated.
  We assume that no two entries associating the same variable
  appear in $[[Θ]]$.

  $[[dom(Θ)]]$ denotes the set of variables appearing in $[[Θ]]$:
  $[[dom(Θ)]] = \{ [[α̂±]] \mid [[α̂±[Γ] ]] \in [[Θ]] \}$.


  If $[[ α̂±[Γ] ]] \in [[Θ]]$, we denote $[[Γ]]$ as $[[Θ(α̂±)]]$.
\end{definition}


\subsection{Subsitutions}

Substitution that operates on algorithmic type variables is denoted as
$[[uσ]]$. It is defined as a total function from algorithmic 
type variables to non-algorithmic types, preserving the polarity.

The signature $[[Θ ⊢ uσ : Ξ]]$ means that
$[[Ξ ⊆ dom(Θ)]]$ and 
$[[uσ]]$ maps each algorithmic variable 
from $[[Ξ]]$ to a type well-formed in $[[Θ(α̂±)]]$;
and for each variable not appearing in $[[dom(Θ)]]$, 
it acts as identity.

\begin{definition}[Signature of Algorithmic Substitution]
  \hfill
  \begin{itemize}
    \item $[[Θ ⊢ uσ : Ξ]]$ means that
      \begin{enumerate}
        \item for any $[[α̂± ∊ Ξ]]$,
          there exists $[[Γ]]$ such that $[[ α̂±[Γ] ∊ Θ ]]$
          and $[[ Γ ⊢ [uσ]α̂± ]]$; 
        \item for any $[[ α̂± ∉ Ξ]]$, $[[ [uσ]α̂± ]] =  [[ α̂± ]]$.
      \end{enumerate}
    \item $[[Γ ⊢ uσ : Ξ]]$ means that
      \begin{enumerate}
        \item for any $[[α̂± ∊ Ξ]]$, $[[ Γ ⊢ [uσ]α̂± ]]$; 
        \item for any $[[ α̂± ∉ Ξ]]$, $[[ [uσ]α̂± ]] =  [[ α̂± ]]$.
      \end{enumerate}
  \end{itemize}
\end{definition}

Anti-unification substitution is denoted as $[[aus]]$ and $[[ausr]]$.
In contrast to algorithmic substitution $[[uσ]]$,
it allows mapping algorithmic variables to
\emph{algorithmic} terms.

The pair of contexts $[[Γ]]$ and $[[Ξ]]$,
in which the results of the anti-unification substitutions 
are formed, is fixed for the whole substitution.
This way, $[[Γ; Ξ2 ⊢ aus : Ξ1]]$ means that $[[aus]]$ maps each negative algorithmic
variable appearing in $[[Ξ1]]$ to a term well-formed in $[[Γ]]$ and $[[Ξ2]]$.

\begin{definition}[Signature of Anti-unification substitution]
  $[[Γ; Ξ2 ⊢ aus : Ξ1]]$ means that
  \begin{enumerate}
    \item for any $[[ α̂⁻ ∊ Ξ1]]$, $[[ Γ; Ξ2 ⊢ [aus]α̂⁻ ]]$ and
    \item for any $[[ α̂⁻ ∉ Ξ1]]$, $[[ [aus]α̂⁻ = α̂⁻ ]]$.
  \end{enumerate}
\end{definition}

\subsection{Normalization}

\subsubsection{Ordering}
\ottdefnsOrder

\subsubsection{Quantifier Normalization}
\ottdefnsNrm

We also define normalization of a substitution pointwise:
\begin{definition}[Substitution Normalization]
  For a substitution $[[σ]]$, we define $[[nf(σ)]]$
  as a substitution that maps $[[α±]]$ into $[[nf([σ]α±)]]$.
\end{definition}

\subsection{Unification}
\ottdefnsU

\subsection{Algorithmic Subtyping}
\ottdefnsA


\subsection{Constraints}

Unification and subtyping algorithms are based on the constraint generation.
The constraints are represented by set of constraint entries.

\begin{definition}[Unification Constraint]
  \hfill
  \begin{itemize}
    \item Unification entry (denoted as $[[ucE]]$) is an expression of shape 
      $[[pua :≈ iP]]$ or $[[nua :≈ iN]]$;
    \item unification constraint (denoted as $[[UC]]$) is a set of 
      unification constraint entries.
  \end{itemize}
\end{definition}

However, in subtyping we need to consider more general
kind of constraints. Specifically,
subtyping constraint entries can restrict a variable
not only to be equivalent to a certain type, but
also to be a supertype of a positive type.

\begin{definition}[Subtyping Constraint]
  \hfill
  \begin{itemize}
    \item Subtyping entry (denoted as $[[scE]]$) is an expression of shape 
      $[[pua :≥ iP]]$, $[[nua :≈ iN]]$, or $[[pua :≈ iP]]$;
    \item subtyping constraint (denoted as $[[SC]]$) is a set of subtyping constraint entries.
  \end{itemize}
\end{definition}

\begin{definition}[Well-formed Constraint Entry]
  We say that a constraint entry is well-formed in a context $[[Γ]]$ if
  the type it restricts the unification variable to is well-formed in $[[Γ]]$.
  \begin{itemize}
    \item $[[Γ ⊢ pua :≥ iP]]$ iff $[[Γ ⊢ iP]]$;
    \item $[[Γ ⊢ pua :≈ iP]]$ iff $[[Γ ⊢ iP]]$;
    \item $[[Γ ⊢ nua :≈ iN]]$ iff $[[Γ ⊢ iN]]$.
  \end{itemize}
\end{definition}


\begin{definition}[Well-formed Constraint]
  We say that a constraint is well-formed in a
  subtyping context $[[Θ]]$ if all its entries are well-formed in
  the corresponding elements of $[[Θ]]$.
  More formally, 
  $[[Θ ⊢ UC]]$ iff for every $[[ucE]] \in $ $[[UC]]$,
  such that $[[ucE]]$ restricts $[[α̂±]]$,
  there exists $[[ α̂±[Γ] ]] \in [[Θ]]$
  and $[[Γ ⊢ ucE]]$.
\end{definition}

Next, define the least upper bound 
for two subtyping constraints.
First, we define the least upper bound for entries,
and then extend it to the set of entries.

\begin{definition} [Matching Entries]
  We call two unification constraint entries 
  or two subtyping constraint entries matching 
  if they are restricting the same unification variable.
\end{definition}

Two matching entries formed in the same context $[[Γ]]$ 
can be merged in the following way:
\begin{definition}[Merge of Matching Constraint Entries]
  \label{definition:merge-matching-entries}
   \hfill \\
  \ottdefnSCME\\
\end{definition}

Unification constraint entries are a special case of subtyping constraint
entries. They are merged using the same algorithm 
(\cref{definition:merge-matching-entries}).
Notice that the merge of two matching unification constraint entries
is a unification constraint entry.
\begin{lemma}[Merge of Matching Unification Constraint Entries is well-defined]
  \label{lemma:merge-matching-entries-welldef}
  Suppose that $[[Γ ⊢ ucE1]]$ and $[[Γ ⊢ ucE2]]$
  are unification constraint entries. 
  Then the merge of $[[ucE1]]$ and $[[ucE2]]$ 
  $[[Γ ⊢ ucE1 & ucE2 = ucE]]$
  according to \cref{definition:merge-matching-entries},
  is a unification constraint entry.
\end{lemma}
\begin{proof}
  Since $[[ucE1]]$ and $[[ucE2]]$ are matching unification constraint entries,
  they have the shape $([[pua :≈ iP1]], [[pua :≈ iP2]])$ or
  $([[nua :≈ iN1]], [[nua :≈ iN2]])$.
  Then the merge of $[[ucE1]]$ and $[[ucE2]]$ 
  can only be defined by \ruleref{\ottdruleSCMEPEqEqLabel} or
  \ruleref{\ottdruleSCMENEqEqLabel}.
  In both cases the result, if it exists, 
  is a unification constraint entry:
  in the first case, the result has shape $[[pua :≈ iP1]]$,
  in the second case, the result has shape $[[nua :≈ iN1]]$.
\end{proof}


% Notice that in case of equivalence, the assigned types
% must be equal (i.e. alpha-equivalent) to be merged. This is because
% the unification algorithm assumes that every type is normalized,
% and hence, equivalence is alpha-equivalence 
% (\cref{corollary:nf-complete-wrt-subt-equiv,corollary:nf-sound-wrt-subt-equiv}).

\begin{definition}[Merge of Subtyping Constraints]
  \label{definition:merge-subtyping-constraints}
  Suppose that $[[Θ ⊢ SC1]]$ and $[[Θ ⊢ SC2]]$.
  Then $[[Θ ⊢ SC1 & SC2 = SC]]$
  defines a set such that $[[ucE]] \in [[SC]]$ iff either
  \begin{itemize}
    \item $[[ucE]] \in [[SC1]]$ and there is no matching $[[ucE']] \in [[SC2]]$; or
    \item $[[ucE]] \in [[SC2]]$ and there is no matching $[[ucE']] \in [[SC1]]$; or
    \item $[[Θ(α̂±) ⊢ ucE1 & ucE2 = ucE]]$ for some $[[ucE1]] \in [[SC1]]$ and $[[ucE2]] \in [[SC2]]$
      such that $[[ucE1]]$ matches with $[[ucE2]]$ restricting variable
      $[[α̂±]]$. 
  \end{itemize}
\end{definition}

Unification constraints can be considered 
as a special case of subtyping constraints,
and the merge of unification constraints
is defined as the merge of subtyping constraints.
Then it is easy to see that the merge of two 
unification constraints is a unification constraint.

\begin{lemma}[Merge of Unification Constraints is well-defined]
  Suppose that $[[Θ ⊢ UC1]]$ and $[[Θ ⊢ UC2]]$
  are unification constraints. 
  Then the merge of $[[UC1]]$ and $[[UC2]]$ 
  $[[Θ ⊢ lift UC1 & lift UC2 = lift UC]]$
  according to \cref{definition:merge-subtyping-constraints},
  is a unification constraint.
\end{lemma}
\begin{proof}
  $[[UC]]$ consists of unmatched entries of $[[UC1]]$ and $[[UC2]]$,
  which are \emph{unification} constraint entries by assumption,
  and merge of matching entries, which also are  
  \emph{unification} constraint entries by \cref{lemma:merge-matching-entries-welldef}.
\end{proof}

\subsection{Constraint Satisfaction}
\ottdefnsSATSCE

\subsection{Least Upper Bound}
\ottdefnsLUB

\subsection{Antiunification}
\ottdefnsAU


\section{Declarative Typing}
 
\subsection{Grammar}

\bigskip
\ottgrammartabular{
  \ottv\ottinterrule
  \ottc\ottinterrule
}

\subsection{Declarative Type Inference}
\ottdefnsDT


\section{Algorithmic Typing}

\subsection{Algorithmic Type Inference}
\ottdefnsAT

\subsection{Singularity}
\ottdefnsSING


\section{Properties of the Declarative Type System}

\subsection{Type Well-formedness}
\input{../_build/_gen/tex/wf-lemmas.tex}

\subsection{Substitution}

\input{../_build/_gen/tex/subst-lemmas.tex}

\subsection{Declarative Subtyping}
\input{../_build/_gen/tex/decl-subtyping-lemmas.tex}

\subsection{Variable Ordering}
\input{../_build/_gen/tex/ord-lemmas.tex}

\subsection{Normaliztaion}
\input{../_build/_gen/tex/norm-lemmas.tex}

\subsection{Equivalence}
\input{../_build/_gen/tex/equiv-lemmas.tex}


\section{Properties of the Algorithmic Type System}

\subsection{Algorithmic Type Well-formedness}
\input{../_build/_gen/tex/wf-algo-lemmas.tex}

\subsection{Substitution}
\input{../_build/_gen/tex/subst-algo-lemmas.tex}

\subsection{Normalization}
\input{../_build/_gen/tex/norm-alg-lemmas.tex}

\subsection{Equivalence}
\input{../_build/_gen/tex/equiv-alg-lemmas.tex}

\subsection{Unification Constraint Merge}
\input{../_build/_gen/tex/unif-constraint-merge-lemmas.tex}

\subsection{Unification}
\input{../_build/_gen/tex/unification-lemmas.tex}\

\subsection{Anti-unification}
\input{../_build/_gen/tex/au-lemmas.tex}

\subsection{Upper Bounds}
\input{../_build/_gen/tex/lub-lemmas.tex}

\subsection{Upgrade}
\input{../_build/_gen/tex/upgrade-lemmas.tex}

\subsection{Constraint Satisfaction}
\input{../_build/_gen/tex/constraint-sat-lemmas.tex}

\subsection{Positive Subtyping}
\input{../_build/_gen/tex/alg-pos-subtyping-lemmas.tex}

\subsection{Subtyping Constraint Merge}
\input{../_build/_gen/tex/constraint-merge-lemmas.tex}

\subsection{Negative Subtyping}
\input{../_build/_gen/tex/alg-neg-subtyping-lemmas.tex}




\section{Properties of the Declarative Typing}
\input{../_build/_gen/tex/decl-typing-lemmas.tex}




\section{Properties of the Algorithmic Typing}

\subsection{Singularity}
\input{../_build/_gen/tex/singularity-lemmas.tex}

\subsection{Correctness of the Typing Algorithm}
\input{../_build/_gen/tex/alg-typing-lemmas.tex}

\end{document}
