\UseRawInputEncoding
% vim: ft=tex
\documentclass[a4,natbib=false]{article}
\usepackage[a4paper, total={8in, 10in}]{geometry}
\usepackage{hyperref}
\usepackage{mathpartir}


\input{prelude.tex}


\input{../_build/_gen/included.tex}




% \renewcommand{\ottdruleEOneNVarName}[0]{ Hello \def\@currentlabelname{FOO} \phantomsection  }
% \newcommand{\ottdrulename}[1]{\textsc{#1}}

% \renewcommand{\ottdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}%
%   }\ruleLabel{#4}{#4}}

% \renewcommand{\ottdrule}[4][]{%
%   {\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}}%
%   \mpr@label{\textsc{#1}}%
% }
% \DeclareDocumentCommand \redrule {m m o}{%
%   \inferrule*[vcenter,left={#3:}]{}{#1 \tred #2}
%   \mpr@label{\textsc{#3}}
% }

% \renewcommand{\ottdrulename}[2][#1]{\textsc{#1} \label{}}


% \renewcommand{\ottdruleEOneNVarName}[0]{foo }

% \makeatletter
% \renewcommand{\ottdruleEOneNVar}[1]{\ottdrule[#1]{%
%   }{
%     % \protected@edef\@currentlabelname{foo}
%     \def\@currentlabelname{foo}%
%     \phantomsection
%     \label{boo}
%     \alpha ^{-}   \eqEOne   \alpha ^{-}
%   }{%
%     {\ottdruleEOneNVarName}{}%
%   } }
% \makeatother


\newcommand{\ruleref}[1]{Rule \nameref{#1}}

% ord varset in uN = varset'

\renewcommand{\ottdruleONVarInName}[0]{(Var$_{\in}^-$)}
\renewcommand{\ottdruleONVarNInName}[0]{(Var$_{\notin}^-$)}
\renewcommand{\ottdruleONUVarName}[0]{(UVar$^-$)}
\renewcommand{\ottdruleOShiftUName}[0]{($\uparrow$)}
\renewcommand{\ottdruleOArrowName}[0]{($\rightarrow$)}
\renewcommand{\ottdruleOForallName}[0]{($\forall$)}


% ord varset in uP = varset'

\renewcommand{\ottdruleOPVarInName}[0]{(Var$_{\in}^+$)}
\renewcommand{\ottdruleOPVarNInName}[0]{(Var$_{\notin}^+$)}
\renewcommand{\ottdruleOPUVarName}[0]{(UVar$^+$)}
\renewcommand{\ottdruleOShiftDName}[0]{($\downarrow$)}
\renewcommand{\ottdruleOExistsName}[0]{($\exists$)}


% nf(N) = M
\renewcommand{\ottdruleNrmNVarName}[0]{(Var$^-$)}
\renewcommand{\ottdruleNrmNUVarName}[0]{(UVar$^-$)}
\renewcommand{\ottdruleNrmShiftUName}[0]{($\uparrow$)}
\renewcommand{\ottdruleNrmArrowName}[0]{($\rightarrow$)}
\renewcommand{\ottdruleNrmForallName}[0]{($\forall$)}

% nf(P) = Q
\renewcommand{\ottdruleNrmPVarName}[0]{(Var$^+$)}
\renewcommand{\ottdruleNrmPUVarName}[0]{(UVar$^+$)}
\renewcommand{\ottdruleNrmShiftDName}[0]{($\downarrow$)}
\renewcommand{\ottdruleNrmExistsName}[0]{($\exists$)}


% N ≈ M

\renewcommand{\ottdruleEOneNVarName}[0]{(Var$^-$$^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftUName}[0]{($\uparrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneArrowName}[0]{($\rightarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneForallName}[0]{($\forall^{\eqEOne}$)}

% P ≈ Q
\renewcommand{\ottdruleEOnePVarName}[0]{(Var$^+$$^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftDName}[0]{($\downarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneExistsName}[0]{($\exists^{\eqEOne}$)}


% G ⊢ N ≤1 M

\renewcommand{\ottdruleDOneNVarName}[0]{(Var$^-$$^{\subDOne}$)}
\renewcommand{\ottdruleDOneShiftUName}[0]{($\uparrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneArrowName}[0]{($\rightarrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneForallName}[0]{($\forall^{\subDOne}$)}

% G ⊢ P ≥1 Q
\renewcommand{\ottdruleDOnePVarName}[0]{(Var$^+$$^{\supDOne}$)}
\renewcommand{\ottdruleDOneShiftDName}[0]{($\downarrow^{\supDOne}$)}
\renewcommand{\ottdruleDOneExistsName}[0]{($\exists^{\supDOne}$)}


% G ⊢ N ≈1 M
\renewcommand{\ottdruleDOneNDefName}[0]{($\eqDOne^{-}$)}

% G ⊢ P ≈1 Q
\renewcommand{\ottdruleDOnePDefName}[0]{($\eqDOne^{+}$)}



% G ⊨ iP1 ∨ iP2 = iQ
\renewcommand{\ottdruleLUBVarName}[0]{(Var$^{\vee}$)}
\renewcommand{\ottdruleLUBShiftName}[0]{($\downarrow^{\vee}$)}
\renewcommand{\ottdruleLUBExistsName}[0]{($\exists^{\vee}$)}
\renewcommand{\ottdruleLUBUpgradeName}[0]{(Upg)}


% G ; Θ ⊨ uN ≤ iM ⫤ us
\renewcommand{\ottdruleANVarName}[0]{(Var$^-$$^{\subA}$)}
\renewcommand{\ottdruleAShiftUName}[0]{($\uparrow^{\subA}$)}
\renewcommand{\ottdruleAArrowName}[0]{($\rightarrow^{\subA}$)}
\renewcommand{\ottdruleAForallName}[0]{($\forall^{\subA}$)}

% G ; Θ ⊨ iP ≥ uQ ⫤ us
\renewcommand{\ottdruleAPVarName}[0]{(Var$^+$$^{\supA}$)}
\renewcommand{\ottdruleAShiftDName}[0]{($\downarrow^{\supA}$)}
\renewcommand{\ottdruleAExistsName}[0]{($\exists^{\supA}$)}
\renewcommand{\ottdruleAPUVarName}[0]{(UVar$^{\supA}$)}

% Γ ⊢ usEntry1 & usEntry2 = usEntry3
\renewcommand{\ottdruleSMESupSupName}[0]{$([[≥]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSMEEqSupName}[0]{$([[≈]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSMESupEqName}[0]{$([[≥]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSMEPEqEqName}[0]{$([[≈]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSMENEqEqName}[0]{$([[≈]]\&^{-}[[≈]])$}


% Γ ⊢ usEntry1 ⇒ usEntry2
\renewcommand{\ottdruleSImpESupSupName}[0]{$([[≥]]\Rightarrow^{+}[[≥]])$}
\renewcommand{\ottdruleSImpEEqSupName}[0]{$([[≈]]\Rightarrow^{+}[[≥]])$}
\renewcommand{\ottdruleSImpEPEqEqName}[0]{$([[≈]]\Rightarrow^{+}[[≈]])$}
\renewcommand{\ottdruleSImpENEqEqName}[0]{$([[≈]]\Rightarrow^{-}[[≈]])$}

% Γ ; Θ ⊨ uN ≈u iM ⫤ us 
\renewcommand{\ottdruleUNVarName}[0]{(Var$^{-[[≈u]]}$)}
\renewcommand{\ottdruleUShiftUName}[0]{($\uparrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUArrowName}[0]{($\rightarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUForallName}[0]{($\forall^{[[≈u]]}$)}
\renewcommand{\ottdruleUNUVarName}[0]{(UVar$^{-[[≈u]]}$)}

% Γ ; Θ ⊨ uP ≈u iQ ⫤ us 
\renewcommand{\ottdruleUPVarName}[0]{(Var$^{+[[≈u]]}$)}
\renewcommand{\ottdruleUShiftDName}[0]{($\downarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUExistsName}[0]{($\exists^{[[≈u]]}$)}
\renewcommand{\ottdruleUPUVarName}[0]{(UVar$^{+[[≈u]]}$)}

\begin{document}

\section{The Vanilla System}



First, we present the top-level system, which is easy to understand.

\subsection{Grammar}
\ottgrammartabular{
  \ottP\ottinterrule
  \ottN\ottinterrule
}

\subsection{Declarative Subtyping}
\ottdefnsDZero

\section{Multi-Quantified System}
\subsection{Grammar}
\ottgrammartabular{
  \ottiP\ottinterrule
  \ottiN\ottinterrule
}
\subsection{Declarative Subtyping}
\ottdefnsDOne


\subsection{Declarative Equivalence}
\ottdefnsEOne


\section{Algorithm}

\subsection{Normalization}
\subsubsection{Ordering}
\ottdefnsOrder

\subsubsection{Quantifier Normalization}
\ottdefnsNrm

% \subsection{Algorithmic Equivalence}
% \ottdefnsEOneA

\subsection{Unification}
\ottdefnsU

\subsection{Algorithmic Subtyping}
\ottdefnsA

\subsection{Unification Solution Weakening}

Unification solution is represented by a list of unification solution entries.
Each entry restricts an unification variable in two possible ways: either
stating that it must be equivalent to a certain type ($[[pua :≈ iP]]$ or $[[nua
:≈ iN]]$) or that it must be a (positive) supertype of a certain type ($[[pua :≥ iP]]$).

\begin{definition} [Matching Entries]
  We call two entries matching if they are restricting the same unification variable.
\end{definition}

Unification solutions are preordered by the weakening relation.
First, let us define the weakening on the unification solution entries.\\

\begin{definition} \hfill \\
\ottdefnSImpE{}\\
\end{definition}
Notice that  $[[Γ ⊢ usEntry1 ⇒ usEntry2]]$ means that $[[usEntry1]]$ and $[[usEntry2]]$ are matching. And 
matching is a equivalence relation on the set of unification solutions. 

Next, we lift the weakening relation to unification solutions.
Informally, $[[Θ ⊢ us1 ⇒ us2]]$ means that for any entry of $[[us2]]$,
there is a matching entry in $[[us1]]$ that is stronger than it. 

\begin{definition}
  Assuming $[[us2 : Θ]]$ and $[[us1 : Θ']] \supseteq [[Θ]]$,
  we say $[[Θ ⊢ us1 ⇒ us2]]$ iff
  $\forall [[usEntry2]] \in [[us2]]$, $\exists [[usEntry1]] \in [[us1]]$ s.t.
  \begin{enumerate}
    \item $[[usEntry1]]$ and $[[usEntry2]]$ are matching, i.e. restricting the same unification variable $[[α̂±]]$;
    \item $[[Θ(α̂±) ⊢ usEntry1 ⇒ usEntry2]]$ (where $[[Θ(α̂±)]]$ is the context corresponding to $[[α̂±]]$ in $[[Θ]]$).
  \end{enumerate}
\end{definition}


\subsection{Unification Solution Merge}

Two matching entries can be merged in the following way:
\begin{definition} \hfill \\
\ottdefnSME\\
\end{definition}
% Notice that in case of equivalence, the assigned types
% must be equal (i.e. alpha-equivalent) to be merged. This is because
% the unification algorithm assumes that every type is normalized,
% and hence, equivalence is alpha-equivalence 
% (\cref{corollary:nf-complete-wrt-subt-equiv,corollary:nf-sound-wrt-subt-equiv}).


To merge two unification solution, we merge each pair of
matching entries, and unite the results.

\begin{definition}
  $\begin{aligned}[t]
  [[us1 & us2]] &= \{ [[usEntry1 & usEntry2]] \mid [[usEntry1]] \in [[us1]],
  [[usEntry2]]  \in [[us2]], \text{s.t. } [[usEntry1]] \text{ matches with }
                                   [[usEntry2]] \}\\
                &\cup
                                     \{ [[usEntry1]] \mid [[usEntry1]] \in
                                     [[us1]], \text{ s.t. }
                                     \forall [[usEntry2]]  \in [[us2]],
                                     [[usEntry1]] \text{ does not match with }
                                                     [[usEntry2]] \}\\
        &\cup
          \{ [[usEntry2]] \mid [[usEntry2]] \in
          [[us2]], \text{ s.t. }
          \forall [[usEntry1]]  \in [[us1]],
          [[usEntry1]] \text{ does not match with }
          [[usEntry2]] \}\\
   \end{aligned}$
\end{definition}



\subsection{Least Upper Bound}
\ottdefnsLUB

\subsection{Antiunification}
\ottdefnsAU

\section{Proofs}

\subsection{Declarative Subtyping}
\input{../_build/_gen/tex/decl-subtyping-lemmas.tex}

\subsection{Substitution}
\input{../_build/_gen/tex/subst-lemmas.tex}

\subsection{Type well-formedness}
\input{../_build/_gen/tex/wf-lemmas.tex}

\subsection{Overview}
\input{../_build/_gen/tex/lemmas-overview.tex}

\subsection{Variable Ordering}
\input{../_build/_gen/tex/ord-lemmas.tex}

\subsection{Normaliztaion}
\input{../_build/_gen/tex/norm-lemmas.tex}

\subsection{Equivalence}
\input{../_build/_gen/tex/equiv-lemmas.tex}

\subsection{Upgrade}
\input{../_build/_gen/tex/upgrade-lemmas.tex}

\subsection{Upper Bounds}

\input{../_build/_gen/tex/lub-lemmas.tex}

\subsection{Unification}
\input{../_build/_gen/tex/unification-lemmas.tex}\

\subsection{Anti-unification}
\input{../_build/_gen/tex/anti-unification-lemmas.tex}

\subsection{Solution Merge}
\input{../_build/_gen/tex/solution-merge-lemmas.tex}

\subsection{Subtyping Algorithm}
\input{../_build/_gen/tex/alg-subtyping-lemmas.tex}

\end{document}
