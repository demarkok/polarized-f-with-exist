\UseRawInputEncoding
% vim: ft=tex
\documentclass[a4,natbib=false]{article}
\usepackage[a4paper, total={8in, 10in}]{geometry}
\usepackage{hyperref}
\usepackage{mathpartir}

\input{prelude.tex}


\input{../_build/_gen/included.tex}




% \renewcommand{\ottdruleEOneNVarName}[0]{ Hello \def\@currentlabelname{FOO} \phantomsection  }
% \newcommand{\ottdrulename}[1]{\textsc{#1}}

% \renewcommand{\ottdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}%
%   }\ruleLabel{#4}{#4}}

% \renewcommand{\ottdrule}[4][]{%
%   {\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}}%
%   \mpr@label{\textsc{#1}}%
% }
% \DeclareDocumentCommand \redrule {m m o}{%
%   \inferrule*[vcenter,left={#3:}]{}{#1 \tred #2}
%   \mpr@label{\textsc{#3}}
% }

% \renewcommand{\ottdrulename}[2][#1]{\textsc{#1} \label{}}


% \renewcommand{\ottdruleEOneNVarName}[0]{foo }

% \makeatletter
% \renewcommand{\ottdruleEOneNVar}[1]{\ottdrule[#1]{%
%   }{
%     % \protected@edef\@currentlabelname{foo}
%     \def\@currentlabelname{foo}%
%     \phantomsection
%     \label{boo}
%     \alpha ^{-}   \eqEOne   \alpha ^{-}
%   }{%
%     {\ottdruleEOneNVarName}{}%
%   } }
% \makeatother


\newcommand{\ruleref}[1]{Rule \nameref{#1}}

% ord varset in uN = varset'

\renewcommand{\ottdruleONVarInName}[0]{(Var$_{\in}^-$)}
\renewcommand{\ottdruleONVarNInName}[0]{(Var$_{\notin}^-$)}
\renewcommand{\ottdruleONUVarName}[0]{(UVar$^-$)}
\renewcommand{\ottdruleOShiftUName}[0]{($\uparrow$)}
\renewcommand{\ottdruleOArrowName}[0]{($\rightarrow$)}
\renewcommand{\ottdruleOForallName}[0]{($\forall$)}


% ord varset in uP = varset'

\renewcommand{\ottdruleOPVarInName}[0]{(Var$_{\in}^+$)}
\renewcommand{\ottdruleOPVarNInName}[0]{(Var$_{\notin}^+$)}
\renewcommand{\ottdruleOPUVarName}[0]{(UVar$^+$)}
\renewcommand{\ottdruleOShiftDName}[0]{($\downarrow$)}
\renewcommand{\ottdruleOExistsName}[0]{($\exists$)}



% nf(N) = M
\renewcommand{\ottdruleNrmNVarName}[0]{(Var$^-$)}
\renewcommand{\ottdruleNrmNUVarName}[0]{(UVar$^-$)}
\renewcommand{\ottdruleNrmShiftUName}[0]{($\uparrow$)}
\renewcommand{\ottdruleNrmArrowName}[0]{($\rightarrow$)}
\renewcommand{\ottdruleNrmForallName}[0]{($\forall$)}

% nf(P) = Q
\renewcommand{\ottdruleNrmPVarName}[0]{(Var$^+$)}
\renewcommand{\ottdruleNrmPUVarName}[0]{(UVar$^+$)}
\renewcommand{\ottdruleNrmShiftDName}[0]{($\downarrow$)}
\renewcommand{\ottdruleNrmExistsName}[0]{($\exists$)}


% N ≈ M

\renewcommand{\ottdruleEOneNVarName}[0]{(Var$^-$$^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftUName}[0]{($\uparrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneArrowName}[0]{($\rightarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneForallName}[0]{($\forall^{\eqEOne}$)}

% P ≈ Q
\renewcommand{\ottdruleEOnePVarName}[0]{(Var$^+$)}
\renewcommand{\ottdruleEOneShiftDName}[0]{($\downarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneExistsName}[0]{($\exists^{\eqEOne}$)}


\renewcommand{\ottdruleSMESupSupName}[0]{$([[≥]]\&[[≥]])$}
\renewcommand{\ottdruleSMEEqSupName}[0]{$([[≈]]\&[[≥]])$}
\renewcommand{\ottdruleSMESupEqName}[0]{$([[≥]]\&[[≈]])$}
\renewcommand{\ottdruleSMEPEqEqName}[0]{$([[≈]]\&[[≈]]^{+})$}
\renewcommand{\ottdruleSMENEqEqName}[0]{$([[≈]]\&[[≈]]^{-})$}



\begin{document}

\section{The Vanilla System}



First, we present the top-level system, which is easy to understand.

\subsection{Grammar}
\ottgrammartabular{
  \ottP\ottinterrule
  \ottN\ottinterrule
}

\subsection{Declarative Subtyping}
\ottdefnsDZero

\section{Multi-Quantified System}
\subsection{Grammar}
\ottgrammartabular{
  \ottiP\ottinterrule
  \ottiN\ottinterrule
}
\subsection{Declarative Subtyping}
\ottdefnsDOne


\subsection{Declarative Equivalence}
\ottdefnsEOne


\section{Algorithm}

\subsection{Normalization}
\subsubsection{Ordering}
\ottdefnsOrder

\subsubsection{Quantifier Normalization}
\ottdefnsNrm

% \subsection{Algorithmic Equivalence}
% \ottdefnsEOneA

\subsection{Unification}
\ottdefnsU

\subsection{Algorithmic Subtyping}
\ottdefnsA

\subsection{Unification Solution Merge}

Unification solution is represented by a list of unification solution entries.
Each entry restrict an unification variable in two possible ways: either stating
that it must be equivalent to a certain type ($[[Δ ⊢ pua :≈ iP]]$ or $[[Δ ⊢ nua :≈
iN]]$) or that it must be a (positive) supertype of a certain type ($[[Δ ⊢ pua :≥
iP]]$).

\begin{definition} [Matching Entries]
  We call two entries matching if they are restricting the same unification variable.
\end{definition}

Two matching entries can be merged in the following way:
\begin{definition} \hfill \\
\ottdefnSME\\
\end{definition}


To merge two unification solution, we merge each pair of
matching entries, and unite the results.

\begin{definition}
  $[[us1 & us2]] = \{ [[usEntry1 & usEntry2]] \mid [[usEntry1]] \in [[us1]],
  [[usEntry2]]  \in [[us2]], \text{s.t. } [[usEntry1]] \text{ matches with } [[usEntry2]] \}$
\end{definition}


\subsection{Least Upper Bound}
\ottdefnsLUB

\subsection{Antiunification}
\ottdefnsAU

\section{Proofs}

\subsection{Overview}
\input{../_build/_gen/tex/lemmas-overview.tex}


\subsection{Variable Ordering}

\input{../_build/_gen/tex/ord-lemmas.tex}

\subsection{Normaliztaion}

\input{../_build/_gen/tex/norm-lemmas.tex}

\subsection{Upper Bounds}

\input{../_build/_gen/tex/lub-lemmas.tex}

\end{document}
