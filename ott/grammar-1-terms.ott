metavar x, y, z, f ::= {{ com term variables }}

% System F
grammar
ft {{ tex t }}, fe {{ tex e }} :: 'ft_' ::= {{ com System F terms }}
  | x           ::   :: Var    % {{ com variable }}
  | λ x . ft    ::   :: UnannLam    % {{ com unannotated abstraction }}
  | Λ as . ft   ::   :: BigLam % {{ com type abstraction }}
  | ft1 ft2     ::   :: App    % {{ com application }}
  | ft1 [ fT ]  :: M :: TApp    % {{ com type application }}
                                {{ tex [[ft1]] \, \{ [[fT]] \} }}
  | ( ft )      :: M :: Paren
  | const       :: M :: Constant
  | [ fargs ]  ::   :: Lst

fvctx, fΦ {{ tex \Gamma }} :: 'fvctxt_' ::= {{ com variable context }}
  | ·                     ::   :: Empty
  | x : fT                ::   :: Single
  | </ fΦi // , // i />   ::   :: Concat  {{ com concatenate contexts }}

fargs {{ tex \vv{ t } }} :: 'fargs_' ::= {{ com list of arguments }}
    | ·                     ::   :: Empty
    | ft                     ::   :: Single
    | ( fargs )              :: M :: Paren
    | </ fargsi // , // i /> ::   :: Concat   {{ com concatenate }}


grammar

args {{ tex \vv{ v } }} :: 'args_' ::= {{ com list of arguments }}
    | ·                     ::   :: Empty    {{ tex }}
    | ∅                     :: M :: EmptyVis {{ tex \cdot }}
                                             {{ com empty (visible in Latex) }}
    | v                     ::   :: Single
    | args1 , args2         ::   :: Concat   {{ com concatenate }}

v, w :: 'v_' ::= {{ com Value Terms }}
  | x          ::   :: Var    % {{ com variable }}
  | { c }      ::   :: Thunk  % {{ com thunk }}
  | ( v : iP ) ::   :: PAnnot % {{ com annotated value }}
  | ( v )      :: M :: Paren
  | const      :: M :: Constant
  | id _ iM    :: M  :: IdM {{ tex \ottkw{id}_{[[iM]]} }}
  | [ bareList ]  :: M  :: Lst

const :: 'const_' ::= {{ com constants }}
  | map       ::   :: Map
  | double    ::   :: Double
  | len       ::   :: Len
  | id        ::   :: Id
  | fortyTwo  ::   :: FortyTwo {{ tex 42 }}
  | one       ::   :: One {{ tex 1 }}
  | two       ::   :: Two {{ tex 2 }}
  | three     ::   :: Trhee {{ tex 3 }}
  | nine      ::   :: Nine {{ tex 9 }}
  | choose    ::   :: Choose
  | auto      ::   :: Auto
  | autoP     ::   :: AutoPrime {{ tex \ottkw{auto'} }}

bareList :: 'bareList_' ::= {{ com bare list }}
  | ·                     ::   :: Empty
  | v                     ::   :: Single
  | </ bareListi // , // i /> ::   :: Concat   {{ com concatenate }}


c, d :: 'c_' ::= {{ com Computation Terms }}
  | ( c : iN )                    ::   :: NAnnot    % {{ com annotated computation }}
  | λ x : iP . c                  ::   :: Lam       % {{ com annotated abstraction }}
  | λ x . c                       :: M :: UALam     % {{ com unannotated abstraction }}
  | ( c )                         :: M :: Paren
                                                    % {{ tex [[λ]] [[x]] : [[iP]] ~.~ [[c]] }}
  | Λ pa . c                      ::   :: BigLam    % {{ com annotated type abstraction }}
  | Λ l ▷ pa . c                  :: M :: BigLamLbl 
  | c [ iPs ]                     :: M :: TypeApp   % {{ com type application }}
                                                    {{ tex [[c]] \{ [[iPs]] \} }}
  | c [ l ▷ iP ]                  :: M :: LblTypeApp   % {{ com type application }}
                                                    {{ tex [[c]] \{ [[l]] [[▷]] [[iP]] \} }}                  
  | c [ l ▷* iP ]                 :: M :: LblTypeAppM {{ tex [[c]] \{ [[l]] [[▷*]] [[iP]] \}  }}  
  | return v                      ::   :: Return    % {{ com computation embedding a value}}
  | let x = v ; c                 ::   :: VarLet    % {{ com standard let-binding }} 
                                                    {{ tex \ottkw{let}\, [[x]] = [[v]] ;~ [[c]] }}
  | let x : iP = c ; c'           ::   :: CVarLet   % {{ com computation sequencing }}
                                                    {{ tex \ottkw{let}\, [[x]] : [[iP]] = [[c]] ;\, [[c']] }}
  | let x : iP = v ( args ) ; c   ::   :: AppLetAnn % {{ com annotated applicative let }}
                                                    {{ tex \ottkw{let}\, [[x]] : [[iP]] = [[v]] ([[args]] ) ;\, [[c]] }}
  | let x      = v ( args ) ; c    ::   :: AppLet    % {{ com unannotated applicative let }} 
                                                    {{ tex \ottkw{let}\, [[x]] = [[v]] ([[args]] ) ;\, [[c]] }}
  | let∃ ( nas , x ) = v    ; c    ::   :: Unpack   % {{ com unpack }}
                                                    {{ tex [[let∃]] ( [[nas]] , [[x]] ) = [[v]] ;\, [[c]] }}

vctx, Φ {{ tex \Gamma }} :: 'vctxt_' ::= {{ com variable context }}
  | ·                     ::   :: Empty
  | x : iP                ::   :: Single
  | Φ1 , Φ2               ::   :: Concat  {{ com concatenate contexts }} 

vctxAl {{ tex \Gamma }} :: 'vctxtAl_' ::= {{ com variable context with algorithmic types }}
  | ·                          ::   :: Empty
  | x : uP                     ::   :: Single
  | </ vctxAli // , // i />    ::   :: Concat  {{ com concatenate contexts }}


funs TERMF ::=

fun Φ ( x ) :: iP :: phiLookupN  by


fun | Φ | :: fΦ :: unpolVCtxt {{ tex | [[Φ]] | }} by 
  | · |         === ·
  | x : iP, Φ | === x : |iP|, |Φ|

fun ft' ●  fargs  :: ft :: multuAppSugar {{tex [[ft']] [[fargs]]}} by 
  ft ●  ·  === ft
  ft ● ft', fargs === (ft ft') ● fargs


fun ft' ● fe *  :: ft :: multuAppStarSugar {{tex (([[ft']] \, [[fe]]_1)\cdots)\,[[fe]]_n }} by 


fun let x = ft1 ; ft2 :: ft :: letSugar by 
  let x = ft1 ; ft2 === (λx.ft2) ft1

fun unpack ( as , x ) = ft1 ; ft2 :: ft :: unpackSugar by 
  unpack ( as , x ) = ft1 ; ft2 === ft1 (Λ as. λx. ft2)

fun pack ft' : fT :: ft :: packSugar 
  {{ tex \ottkw{pack}\, [[ft']]\, \ottkw{as}\, [[fT]] }} by 
  pack ft : fT === Λb. λf. f ft


fun +| fΦ |+  :: Φ :: polVCtxt {{ tex \downharpoonlefttight [[fΦ]] \downharpoonrighttight }} by 
  +| · |+  === ·                               
  +| x : fT, fΦ |+ === x : +|fT|+, +|fΦ|+  
