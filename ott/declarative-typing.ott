defns
  DT :: 'DT' ::=

  defn Γ ; Φ ⊢ v : iP :: :: PInf :: ''
  {{ com Positive type inference }}
  {{ tex [[Γ]] ; [[Φ]] \vdash [[v]] \colon [[iP]] }} by 

  v : iP ∊ Φ
  --------------- :: Var
  Γ ; Φ ⊢ v : iP

  Γ ; Φ ⊢ c : iN
  ------------------- :: Thunk
  Γ ; Φ ⊢ {c} : ↓iN

  Γ ; Φ ⊢ v : iP    Γ ⊢ iQ ≥ iP
  ------------------------------ :: AnnotP
  Γ ; Φ ⊢ (v : iQ) : iQ

  defn Γ ; Φ ⊢ c : iN :: :: NInf :: ''
  {{ com Negative type inference }}
  {{ tex [[Γ]] ; [[Φ]] \vdash [[c]] \colon [[iN]] }} by

  Γ ; Φ, x:iP ⊢ c : iN 
  ---------------------------- :: tLam
  Γ ; Φ ⊢ λx:iP . c : iP → iN

  Γ, α⁺ ; Φ ⊢ c : iN
  ------------------------- :: TLam
  Γ ; Φ ⊢ Λα⁺ . c : ∀α⁺.iN

  Γ ; Φ ⊢ v : iP
  ----------------------- :: Return
  Γ ; Φ ⊢ return v : ↑iP

  Γ ; Φ ⊢ v : ↓iM   Γ ; Φ ⊢ iM ● args ⇒> ↑iQ   Γ ⊢ ↑iQ ≤ ↑iP   Γ; Φ, x:iP ⊢ c : iN
  ------------------------------------------------------------- :: LetAnn
  Γ ; Φ ⊢ let x:iP = v(args); c : iN

  Γ ; Φ ⊢ v : ↓iM   Γ ; Φ ⊢ iM ● args ⇒> ↑iQ uniq   Γ; Φ, x:iQ ⊢ c : iN
  ------------------------------------------------------------------ :: Let
  Γ ; Φ ⊢ let x = v(args); c : iN

  Γ, α⁻ ; Φ ⊢ v : ∃α⁻.iP   Γ, α⁻ ; Φ, x:iP ⊢ c : iN   Γ ⊢ iN
  ----------------------------------------------------------- :: Unpack
  Γ ; Φ ⊢ let∃ (α⁻, x) = v; c : iN

  Γ ; Φ ⊢ c : iN    Γ ⊢ iN ≤ iM
  ------------------------------ :: AnnotN
  Γ ; Φ ⊢ (c : iM) : iM

defn Γ ; Φ ⊢ iN ● args ⇒> iM :: :: SpinInf :: ''
{{ com Spin Application type inference }} by

iN ≠ ∀pas.iM
---------------------- :: Emtpty
Γ ; Φ ⊢ iN ● · ⇒> iN 

Γ ; Φ ⊢ v : iP   Γ ⊢ iQ ≥ iP  Γ ; Φ ⊢ iN ● args ⇒> iM
------------------------------------------------------ :: Arrow
Γ ; Φ ⊢ iQ → iN ● v , args ⇒> iM

 Γ ⊢ iPs       Γ ; Φ ⊢ [iPs/pas]iN ● args ⇒> iM
------------------------------------------------ :: Forall
Γ ; Φ ⊢ ∀pas.iN ● args ⇒> iM


