% \renewcommand{\ottprodinline}[4]{\multicolumn{3}{l}{#1} \\ $#2$ &$#3$& $#4$}
% \renewcommand{\ottcInline}{\ottprodinline{\ottcom{Computation Terms}}{\ottnt{c} ,\ \ottnt{d}}{\Coloneqq}
% {\mbox{\ottsym{(}  \ottnt{c}  \ottsym{:} \mathcolor{negative}{N}  \ottsym{)}}}}

\renewcommand{\ottkw}[1]{{\bf \tt{#1}}}

\newcommand{\ottdefnTELNLabeledTwoColumns}[1]{
    \begin{ottdefnblock}[#1]{\ottdefnHeaderTELN}{\ottcom{Negative typing elaboration}}
        \begin{minipage}[t]{0.5\textwidth}
            \ottusedrule{\ottdruleTELtLamLabeled{}}
            \ottusedrule{\ottdruleTELReturnLabeled{}}
            \ottusedrule{\ottdruleTELNEquivLabeled{}}
        \end{minipage}%
        \begin{minipage}[t]{0.5\textwidth}
            \ottusedrule{\ottdruleTELTLamLabeled{}}
            \ottusedrule{\ottdruleTELVarLetLabeled{}}
            \ottusedrule{\ottdruleTELNAnnotLabeled{}}
        \end{minipage}
        \ottusedrule{\ottdruleTELAppLetLabeled{}}
        \ottusedrule{\ottdruleTELAppLetAnnLabeled{}}
        \ottusedrule{\ottdruleTELUnpackLabeled{}}
        \ottusedrule{\ottdruleTELCVarLetLabeled{}}
    \end{ottdefnblock}
}

\newcommand{\ottdefnTELPAppLabeled}[1]{
    \begin{minipage}[t]{0.45\textwidth}
        \begin{ottdefnblock}[#1]{\ottdefnHeaderTELP}{\ottcom{Positive typing elaboration}}
            \ottusedrule{\ottdruleTELVarLabeled{}}
            \ottusedrule{\ottdruleTELThunkLabeled{}}
            \ottusedrule{\ottdruleTELPAnnotLabeled{}}
            \ottusedrule{\ottdruleTELPEquivLabeled{}}
        \end{ottdefnblock}
    \end{minipage}
    \begin{minipage}[t]{0.5\textwidth}
        \begin{ottdefnblock}[#1]{\ottdefnHeaderTELApp}{\ottcom{Application typing}}
        \ottusedrule{\ottdruleTELEmptyAppLabeled{}}
        \ottusedrule{\ottdruleTELArrowAppLabeled{}}
        \ottusedrule{\ottdruleTELForallAppLabeled{}}
        \end{ottdefnblock}
    \end{minipage}
}




\newcommand{\ottdefnELLabeled}[0]{
    \framebox{\mbox{\ottdefnHeaderELN}} \quad
    \framebox{\mbox{\ottdefnHeaderELP}}
    \begin{minipage}[t]{0.5\textwidth}
        \ottusedrule{\ottdruleELNVarLabeled{}}
        \ottusedrule{\ottdruleELShiftULabeled{}}
    \end{minipage}%
    \begin{minipage}[t]{0.5\textwidth}
        \ottusedrule{\ottdruleELPVarLabeled{}}
        \ottusedrule{\ottdruleELShiftDLabeled{}}
    \end{minipage}
    \ottusedrule{\ottdruleELArrowLabeled{}}
    \ottusedrule{\ottdruleELExistsLabeled{}}
    \ottusedrule{\ottdruleELForallLabeled{}}
}

\newcommand{\ottdefnSFtyLabeledTwoColumns}[0]{
    \begin{minipage}{0.5\textwidth}
        \ottusedrule{\ottdruleSFtyVarLabeled{}}
        \ottusedrule{\ottdruleSFtytLamLabeled{}}
        \ottusedrule{\ottdruleSFtyAppLabeled{}}
    \end{minipage}%
    \begin{minipage}{0.5\textwidth}
        \ottusedrule{\ottdruleSFtyTLamLabeled{}}
        \ottusedrule{\ottdruleSFtyTAppLabeled{}}
    \end{minipage}
}

\newcommand{\ottdefnMININSTLabeled}[0]{
    \begin{minipage}{0.5\textwidth}
        \ottusedrule{\ottdruleSINGPUvarLabeled{}}
        \ottusedrule{\ottdruleSINGExistsLabeled{}}
    \end{minipage}%
    \begin{minipage}{0.5\textwidth}
        \ottusedrule{\ottdruleSINGSingLabeled{}}
    \end{minipage}
}

\newcommand{\ottdefnSINGLabeled}[0]{
    % \begin{minipage}{0.5\textwidth}
        \ottusedrule{\ottdruleSINGPEqLabeled{}}
        \ottusedrule{\ottdruleSINGNEqLabeled{}}
    % \end{minipage}%
    % \begin{minipage}{0.5\textwidth}
        \ottusedrule{\ottdruleSINGSupVarLabeled{}}
        \ottusedrule{\ottdruleSINGSupShiftLabeled{}}
    % \end{minipage}
}

\newcommand{\ottuGrammarExt}[4]{\ottgrammartabular{
    \multicolumn{5}{l}{#1}\ottprodnewline$#2$ & $#3$ & $\cdots$ & $\mid$ & $#4$\ottinterrule}}

\newcommand{\ottuNShort}[0]
    {\ottuGrammarExt{\ottcom{Negative Algorithmic Types}}
                   { \negAlgType{N}  ,\ \negAlgType{M} }
                   {\Coloneqq}
                   {\widehat{ \mathcolor{negative}{\alpha} }^{-}}}

\newcommand{\ottuPShort}[0]
    {\ottuGrammarExt{\ottcom{Positive Algorithmic Types}}
                   { \posAlgType{P}  ,\ \posAlgType{Q} }
                   {\Coloneqq}
                   {\widehat{ \mathcolor{positive}{\alpha} }^{+}}}

% \ottrulehead{}{::=}{\ottcom{Negative algorithmic type}}
% \ottprodnewline 
% \ottfirstprodline{|}{\widehat{ \mathcolor{negative}{\alpha} }^{-}}{}{}{}{}}


\renewcommand{\ottrulehead}[3]{\multicolumn{4}{l}{#3}\ottprodnewline$#1$ & & $#2$ & & }

\renewcommand{\ottdefnATNInfLabeled}[1]{\begin{ottdefnblock}[#1]{\ottdefnHeaderATNInf}{\ottcom{Negative typing}}
    \begin{multicols}{2}
        \ottusedrule{\ottdruleATNAnnotLabeled{}}
        \ottusedrule{\ottdruleATtLamLabeled{}}
        \ottusedrule{\ottdruleATTLamLabeled{}}
        \ottusedrule{\ottdruleATReturnLabeled{}}
        \ottusedrule{\ottdruleATVarLetLabeled{}}
        \ottusedrule{\ottdruleATCVarLetLabeled{}}
    \ottusedrule{\ottdruleATUnpackLabeled{}}
    \end{multicols}
    \ottusedrule{\ottdruleATAppLetAnnLabeled{}}
    \ottusedrule{\ottdruleATAppLetLabeled{}}
\end{ottdefnblock}}


\renewcommand{\ottdefnATPInfLabeled}[1]{\begin{ottdefnblock}[#1]{\ottdefnHeaderATPInf}{\ottcom{Positive typing}}
    \begin{multicols}{3}
        \ottusedrule{\ottdruleATVarLabeled{}}
        \columnbreak\\
        \ottusedrule{\ottdruleATPAnnotLabeled{}}
        \columnbreak\\
        \ottusedrule{\ottdruleATThunkLabeled{}}
    \end{multicols}
\end{ottdefnblock}}

\renewcommand{\ottdefnATSpinInfLabeled}[1]{\begin{ottdefnblock}[#1]{\ottdefnHeaderATSpinInf}{\ottcom{Application typing}}
    \begin{multicols}{2}
        \ottusedrule{\ottdruleATEmptyAppLabeled{}}
        \columnbreak\\
        \ottusedrule{\hspace{-.9cm}\ottdruleATArrowAppLabeled{}}
    \end{multicols}
    \ottusedrule{\ottdruleATForallAppLabeled{}}
\end{ottdefnblock}}

% \begin{figure}
%   \ottdefnATNInfLabeled{}
%   \caption{Algorithmic Negative Type Inferences}
%   \label{fig:type-inference}
% \end{figure}

% \begin{figure}
%   \ottdefnATPInfLabeled{}
%   \caption{Algorithmic Positive Type Inferences}
%   \label{fig:type-inference-pos}
% \end{figure}

% \begin{figure}
%   \ottdefnATSpinInfLabeled{}
%   \caption{Algorithmic Application Type Inferences}
%   \label{fig:type-inference-app}
% \end{figure}


\renewcommand{\ottdefnDTNInfLabeled}[1]{
    \begin{ottdefnblock}[#1]{\ottdefnHeaderDTNInf}{\ottcom{Negative typing}}
        \begin{minipage}[t]{0.49\textwidth}
            \ottusedrule{\ottdruleDTtLamLabeled{}}
            \ottusedrule{\ottdruleDTTLamLabeled{}}
            \ottusedrule{\ottdruleDTReturnLabeled{}}
            \ottusedrule{\ottdruleDTVarLetLabeled{}}
            \ottusedrule{\ottdruleDTCVarLetLabeled{}}
            \ottusedrule{\ottdruleDTNEquivLabeled{}}
        \end{minipage}
        \begin{minipage}[t]{0.49\textwidth}
            \ottusedrule{\ottdruleDTAppLetLabeled{}}
            \ottusedrule{\ottdruleDTAppLetAnnLabeled{}}
            \ottusedrule{\ottdruleDTUnpackLabeled{}}
            \ottusedrule{\hspace{-.5cm}\ottdruleDTNAnnotLabeled{}}
        \end{minipage}
    \end{ottdefnblock}}

\renewcommand{\ottdefnDTSpinInfLabeled}[1]{
    \begin{ottdefnblock}[#1]{\ottdefnHeaderDTSpinInf}{\ottcom{Application typing}}
        \begin{minipage}{0.49\textwidth}
            \ottusedrule{\ottdruleDTEmptyAppLabeled{}}
            \ottusedrule{\ottdruleDTArrowAppLabeled{}}
        \end{minipage}
        \begin{minipage}{0.49\textwidth}
            \ottusedrule{\ottdruleDTForallAppLabeled{}}
        \end{minipage}
    \end{ottdefnblock}}

\renewcommand{\ottdefnDTPInfLabeled}[1]{
    \begin{ottdefnblock}[#1]{\ottdefnHeaderDTPInf}{\ottcom{Positive typing}}
        \begin{minipage}{0.49\textwidth}
            \ottusedrule{\ottdruleDTVarLabeled{}}
            \ottusedrule{\ottdruleDTThunkLabeled{}}
        \end{minipage}
        \begin{minipage}{0.49\textwidth}
            \ottusedrule{\ottdruleDTPAnnotLabeled{}}
            \ottusedrule{\ottdruleDTPEquivLabeled{}}
        \end{minipage}
    \end{ottdefnblock}
}


\renewcommand{\ottdefnATPInf}[1]{\begin{ottdefnblock}[#1]{\ottdefnHeaderATPInf}{\ottcom{Positive typing}}
    \begin{multicols}{2}
        \ottusedrule{\ottdruleATVar{}}
        \columnbreak\\
        \ottusedrule{\ottdruleATThunk{}}
    \end{multicols}
    \ottusedrule{\ottdruleATPAnnot{}}
\end{ottdefnblock}}


\newcommand{\ottdefnsDTLabeled}{
    \ottdefnDTNInfLabeled{}
    \hfill\\
    \ottdefnDTPInfLabeled{}
    \hfill\\
    \ottdefnDTSpinInfLabeled{}
}


% \renewcommand{\ottdefnATSpinInf}[1]{\begin{ottdefnblock}[#1]{\ottdefnHeaderATSpinInf}{\ottcom{Application typing}}
% \begin{multicols}{2}
%     \ottusedrule{\ottdruleATEmptyApp{}}
%     \columnbreak\\
%     \ottusedrule{\ottdruleATArrowApp{}}
% \end{multicols}
% \ottusedrule{\ottdruleATForallApp{}}
% \end{ottdefnblock}}


\renewcommand{\ottdefnAPsupLabeled}[1]{\begin{ottdefnblock}[#1]{\ottdefnHeaderAPsup}{\ottcom{Positive supertyping}}
\ottusedrule{\ottdruleAPVarLabeled{}}
\ottusedrule{\hspace{-1cm}\ottdruleAExistsLabeled{}}
\ottusedrule{\ottdruleAShiftDLabeled{}}
\ottusedrule{\ottdruleAPUVarLabeled{}}
\end{ottdefnblock}}

\renewcommand{\ottdefnAUAUN}[1]{\begin{ottdefnblock}[#1]{\ottdefnHeaderAUAUN}{}
    \begin{multicols}{2}
        \ottusedrule{\ottdruleAUNVar{}}
        \columnbreak\\
        \ottusedrule{\ottdruleAUShiftU{}}
    \end{multicols}
    \ottusedrule{\ottdruleAUForall{}}
    \ottusedrule{\ottdruleAUArrow{}}
    \ottusedrule{\ottdruleAUAU{}}
\end{ottdefnblock}}

\renewcommand{\ottdefnAUAUP}[1]{\begin{ottdefnblock}[#1]{\ottdefnHeaderAUAUP}{}
    \begin{multicols}{2}
        \ottusedrule{\ottdruleAUPVar{}}
        \columnbreak\\
        \ottusedrule{\ottdruleAUShiftD{}}
    \end{multicols}
    \ottusedrule{\ottdruleAUExists{}}
\end{ottdefnblock}}


\renewcommand{\ottrulehead}[3]{\multicolumn{4}{l}{#3}\ottprodnewline$#1$ & & $#2$ & & }
\newcommand{\ottruleheadOneLine}[4]{\multicolumn{4}{l}{#3}\ottprodnewline$#1$ & & $#2$ & $#4$ & }
% \renewenvironment{ottdefnblock}[3][]{\noindent#3 \\\framebox{\mbox{#2}}\\[0pt]}{}
\renewcommand{\ottusedrule}[1]{\[#1\]\smallskip}



% ord varset in uN = varset'

\renewcommand{\ottdruleONVarInName}[0]{(Var$_{-\in}^{\text{Ord}}$)}
\renewcommand{\ottdruleONVarNInName}[0]{(Var$_{-\notin}^{\text{Ord}}$)}
\renewcommand{\ottdruleONUVarName}[0]{(UVar$_{-} ^{\text{Ord}}$)}
\renewcommand{\ottdruleOShiftUName}[0]{($\uparrow^{\text{Ord}}$)}
\renewcommand{\ottdruleOArrowName}[0]{($\rightarrow^{\text{Ord}}$)}
\renewcommand{\ottdruleOForallName}[0]{($\forall^{\text{Ord}}$)}


% ord varset in uP = varset'

\renewcommand{\ottdruleOPVarInName}[0]{(Var$_{+\in}^{\text{Ord}}$)}
\renewcommand{\ottdruleOPVarNInName}[0]{(Var$_{+\notin}^{\text{Ord}}$)}
\renewcommand{\ottdruleOPUVarName}[0]{(UVar$_{+}^{\text{Ord}}$)}
\renewcommand{\ottdruleOShiftDName}[0]{($\downarrow^{\text{Ord}}$)}
\renewcommand{\ottdruleOExistsName}[0]{($\exists^{\text{Ord}}$)}


% nf(N) = M
\renewcommand{\ottdruleNrmNVarName}[0]{(Var$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmNUVarName}[0]{(UVar$_{-}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmShiftUName}[0]{($\uparrow^{\text{nf}}$)}
\renewcommand{\ottdruleNrmArrowName}[0]{($\rightarrow^{\text{nf}}$)}
\renewcommand{\ottdruleNrmForallName}[0]{($\forall^{\text{nf}}$)}

% nf(P) = Q
\renewcommand{\ottdruleNrmPVarName}[0]{(Var$_{+}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmPUVarName}[0]{(UVar$_{+}^{\text{nf}}$)}
\renewcommand{\ottdruleNrmShiftDName}[0]{($\downarrow^{\text{nf}}$)}
\renewcommand{\ottdruleNrmExistsName}[0]{($\exists^{\text{nf}}$)}


% N ≈ M

\renewcommand{\ottdruleEOneNVarName}[0]{(Var$_-^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftUName}[0]{($\uparrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneArrowName}[0]{($\rightarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneForallName}[0]{($\forall^{\eqEOne}$)}

% P ≈ Q
\renewcommand{\ottdruleEOnePVarName}[0]{(Var$_+^{\eqEOne}$)}
\renewcommand{\ottdruleEOneShiftDName}[0]{($\downarrow^{\eqEOne}$)}
\renewcommand{\ottdruleEOneExistsName}[0]{($\exists^{\eqEOne}$)}


% G ⊢ N ≤1 M

\renewcommand{\ottdruleDOneNVarName}[0]{(Var$_-^{\subDOne}$)}
\renewcommand{\ottdruleDOneShiftUName}[0]{($\uparrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneArrowName}[0]{($\rightarrow^{\subDOne}$)}
\renewcommand{\ottdruleDOneForallName}[0]{($\forall^{\subDOne}$)}

\renewcommand{\ottdruleDOneEForallLRUbName}[0]{(E$\forall^{\subDOne}$)}

\renewcommand{\ottdruleDOneEForallRName}[0]{(E$\forall^{\subDOne}_{\text{R}}$)}
\renewcommand{\ottdruleDOneEForallLName}[0]{(E$\forall^{\subDOne}_{\text{L}}$)}
\renewcommand{\ottdruleDOneEForallLRName}[0]{(E$\forall^{\subDOne}$)}

\renewcommand{\ottdruleDOneEForallRUbUbName}[0]{(E$\forall^{\subDOne}_{\text{R}}$)}
\renewcommand{\ottdruleDOneEForallLUbName}[0]{(E$\forall^{\subDOne}_{\text{L}}$)}

\renewcommand{\ottdruleDOneShiftURlxName}[0]{($\uparrow^{\subDOne}_{\text{Rlx}}$)}

\renewcommand{\ottdruleDOneLblForallLRName}[0]{($\forall^{\subDOne}$)}

% G ⊢ P ≥1 Q
\renewcommand{\ottdruleDOnePVarName}[0]{(Var$_+^{\supDOne}$)}
\renewcommand{\ottdruleDOneShiftDName}[0]{($\downarrow^{\supDOne}$)}
\renewcommand{\ottdruleDOneExistsName}[0]{($\exists^{\supDOne}$)}

\renewcommand{\ottdruleDOneEExistsRName}[0]{(E$\exists^{\supDOne}_{\text{R}}$)}
\renewcommand{\ottdruleDOneEExistsLName}[0]{(E$\exists^{\supDOne}_{\text{L}}$)}
\renewcommand{\ottdruleDOneEExistsLRName}[0]{(E$\exists^{\supDOne}$)}




% G ⊢ N ≈1 M
\renewcommand{\ottdruleDOneNDefName}[0]{($\eqDOneNeg$)}

% G ⊢ P ≈1 Q
\renewcommand{\ottdruleDOnePDefName}[0]{($\eqDOnePos$)}



% G ⊨ iP1 ∨ iP2 = iQ
\renewcommand{\ottdruleLUBVarName}[0]{(Var$^{\vee}$)}
\renewcommand{\ottdruleLUBShiftName}[0]{($\downarrow^{\vee}$)}
\renewcommand{\ottdruleLUBExistsName}[0]{($\exists^{\vee}$)}
\renewcommand{\ottdruleLUBUpgradeName}[0]{(Upg)}

\renewcommand{\ottdruleLUBEExistsName}[0]{(E$\exists^{\vee}$)}


% G ; Θ ⊨ uN ≤ iM ⫤ us
\renewcommand{\ottdruleANVarName}[0]{(Var$_-^{\subA}$)}
\renewcommand{\ottdruleAShiftUName}[0]{($\uparrow^{\subA}$)}
\renewcommand{\ottdruleAArrowName}[0]{($\rightarrow^{\subA}$)}
\renewcommand{\ottdruleAForallName}[0]{($\forall^{\subA}$)}

\renewcommand{\ottdruleAForallLName}[0]{(E$\forall^{\subA}_{\text{L}}$)}
\renewcommand{\ottdruleAForallRName}[0]{(E$\forall^{\subA}_{\text{R}}$)}
\renewcommand{\ottdruleAForallLRName}[0]{(E$\forall^{\subA}$)}

\renewcommand{\ottdruleAEForallLRUbName}[0]{(E$\forall^{\subA}$)}


\renewcommand{\ottdruleAShiftURlxName}[0]{($\uparrow^{\subA}_{\text{Rlx}}$)}


% G ; Θ ⊨ iP ≥ uQ ⫤ us
\renewcommand{\ottdruleAPVarName}[0]{(Var$_+^{\supA}$)}
\renewcommand{\ottdruleAShiftDName}[0]{($\downarrow^{\supA}$)}
\renewcommand{\ottdruleAExistsName}[0]{($\exists^{\supA}$)}
\renewcommand{\ottdruleAPUVarName}[0]{(UVar$^{\supA}$)}


% Γ ⊢ scE1 & scE2 = scE3 :: :: E :: 'E'
\renewcommand{\ottdruleSCMESupSupName}[0]{$([[≥]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSCMEEqSupName}[0]{$([[≈]]\&^{+}[[≥]])$}
\renewcommand{\ottdruleSCMESupEqName}[0]{$([[≥]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSCMEPEqEqName}[0]{$([[≈]]\&^{+}[[≈]])$}
\renewcommand{\ottdruleSCMENEqEqName}[0]{$([[≈]]\&^{-}[[≈]])$}

% Γ ; Θ ⊨ uN ≈u iM ⫤ UC 
\renewcommand{\ottdruleUNVarName}[0]{(Var$_{-}^{[[≈u]]}$)}
\renewcommand{\ottdruleUShiftUName}[0]{($\uparrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUArrowName}[0]{($\rightarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUForallName}[0]{($\forall^{[[≈u]]}$)}
\renewcommand{\ottdruleUNUVarName}[0]{(UVar$_{-}^{[[≈u]]}$)}

% Γ ; Θ ⊨ uP ≈u iQ ⫤ UC 
\renewcommand{\ottdruleUPVarName}[0]{(Var$_{+}^{[[≈u]]}$)}
\renewcommand{\ottdruleUShiftDName}[0]{($\downarrow^{[[≈u]]}$)}
\renewcommand{\ottdruleUExistsName}[0]{($\exists^{[[≈u]]}$)}
\renewcommand{\ottdruleUPUVarName}[0]{(UVar$_{+}^{[[≈u]]}$)}

% G ⊨ iP1 ≈au iP2 ⫤ ( Ξ , uQ , aus1 , aus2 )
\renewcommand{\ottdruleAUPVarName}[0]{(Var$_{+}^{[[≈au]]}$)}
\renewcommand{\ottdruleAUShiftDName}[0]{($\downarrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUExistsName}[0]{($\exists^{[[≈au]]}$)}

% G ⊨ iN1 ≈au iN2 ⫤ ( Ξ , uM , aus1 , aus2 )
\renewcommand{\ottdruleAUNVarName}[0]{(Var$_{-}^{[[≈au]]}$)}
\renewcommand{\ottdruleAUShiftUName}[0]{($\uparrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUForallName}[0]{($\forall^{[[≈au]]}$)}
\renewcommand{\ottdruleAUArrowName}[0]{($\rightarrow^{[[≈au]]}$)}
\renewcommand{\ottdruleAUAUName}[0]{(AU)}

% Γ ⊢ iN 
\renewcommand{\ottdruleWFTNVarName}[0]{(Var$_{-}^{\text{WF}}$)}
\renewcommand{\ottdruleWFTShiftUName}[0]{($\uparrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFTArrowName}[0]{($\rightarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFTForallName}[0]{($\forall^{\text{WF}}$)}
\renewcommand{\ottdruleWFTForallUbName}[0]{($\forall^{\text{WF}}$)}

% Γ ⊢ iP
\renewcommand{\ottdruleWFTPVarName}[0]{(Var$_{+}^{\text{WF}}$)}
\renewcommand{\ottdruleWFTShiftDName}[0]{($\downarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFTExistsName}[0]{($\exists^{\text{WF}}$)}

% Γ ; Ξ ⊢ uN
\renewcommand{\ottdruleWFATNVarName}[0]{(Var$_{-}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATNUVarName}[0]{(UVar$_{-}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATShiftUName}[0]{($\uparrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFATArrowName}[0]{($\rightarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFATForallName}[0]{($\forall^{\text{WF}}$)}

% Γ ; Ξ ⊢ uP
\renewcommand{\ottdruleWFATPVarName}[0]{(Var$_{+}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATPUVarName}[0]{(UVar$_{+}^{\text{WF}}$)}
\renewcommand{\ottdruleWFATShiftDName}[0]{($\downarrow^{\text{WF}}$)}
\renewcommand{\ottdruleWFATExistsName}[0]{($\exists^{\text{WF}}$)}

% Γ ⊢ iP : scE
\renewcommand{\ottdruleSATSCESupName}[0]{($[[:≥]]_{+}^\text{sat}$)}
\renewcommand{\ottdruleSATSCEPEqName}[0]{($[[:≈]]_{+}^\text{sat}$)}

% Γ ⊢ iN : scE
\renewcommand{\ottdruleSATSCENEqName}[0]{($[[:≈]]_{-}^\text{sat}$)}

% Γ ; Φ ⊢ v : iP 
\renewcommand{\ottdruleDTVarName}[0]{(Var$^{\text{inf}}$)}
\renewcommand{\ottdruleDTThunkName}[0]{($\{\}^{\text{inf}}$)}
\renewcommand{\ottdruleDTPAnnotName}[0]{(ann$_+^{\text{inf}}$)}
\renewcommand{\ottdruleDTPEquivName}[0]{($[[≈]]_+^{\text{inf}}$)}

% Γ ; Φ ⊢ c : iN 
\renewcommand{\ottdruleDTtLamName}[0]{($\lambda^{\text{inf}}$)}
\renewcommand{\ottdruleDTTLamName}[0]{($\Lambda^{\text{inf}}$)}
\renewcommand{\ottdruleDTReturnName}[0]{(ret$^{\text{inf}}$)}
\renewcommand{\ottdruleDTVarLetName}[0]{(let$^{\text{inf}}$)}
\renewcommand{\ottdruleDTCVarLetName}[0]{(let$_{\text{c}}^{\text{inf}}$)}
\renewcommand{\ottdruleDTAppLetName}[0]{(let$_@^{\text{inf}}$)}
\renewcommand{\ottdruleDTAppLetAnnName}[0]{(let$_{:@}^{\text{inf}}$)}
\renewcommand{\ottdruleDTUnpackName}[0]{(let$_{\exists}^{\text{inf}}$)}
\renewcommand{\ottdruleDTNAnnotName}[0]{(ann$_-^{\text{inf}}$)}
\renewcommand{\ottdruleDTNEquivName}[0]{($[[≈]]_-^{\text{inf}}$)}
\renewcommand{\ottdruleDTTypeAppName}[0]{($TApp^{\text{inf}}$)}
\renewcommand{\ottdruleDTTypeAppOrderedName}[0]{($TApp^{\text{inf}}$)}

\renewcommand{\ottdruleDTTLamLbName}[0]{($\Lambda^{\text{inf}}$)}
\renewcommand{\ottdruleDTTypeAppLbName}[0]{($TApp^{\text{inf}}$)}

% Γ ; Φ ⊢ iN ● args ⇒> iM 
\renewcommand{\ottdruleDTEmptyAppName}[0]{($\emptyset_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleDTArrowAppName}[0]{($\rightarrow_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleDTForallAppName}[0]{($\forall_{[[●]][[⇒>]]}^{\text{inf}}$)}


% (Bbidir)

% Γ ; Φ ⊢ c ⇒ iN 
\renewcommand{\ottdruleDTtLamSynName}[0]{($\lambda^{[[⇐]]}$)}
\renewcommand{\ottdruleDTTLamSynName}[0]{($\Lambda^{[[⇐]]}$)}
\renewcommand{\ottdruleDTNAnnotSynName}[0]{(ann$_-^{[[⇐]]}$)}

% Γ ; Φ ⊢ c ⇐ iN 
\renewcommand{\ottdruleDTtLamChkName}[0]{($\lambda^{[[⇐]]}$)}
\renewcommand{\ottdruleDTNSubName}[0]{(SUB$_{-}$)}

% Γ ; Φ ⊢ c ⇔ iN 
\renewcommand{\ottdruleDTReturnChkSynName}[0]{(ret$^{[[⇔]]}$)}
\renewcommand{\ottdruleDTVarLetChkSynName}[0]{(let$^{[[⇔]]}$)}
\renewcommand{\ottdruleDTAppLetChkSynName}[0]{(let$_@^{[[⇔]]}$)}
\renewcommand{\ottdruleDTAppLetAnnChkSynName}[0]{(let$_{:@}^{[[⇔]]}$)}
\renewcommand{\ottdruleDTUnpackChkSynName}[0]{(let$_{\exists}^{[[⇔]]}$)}
\renewcommand{\ottdruleDTNEquivChkSynName}[0]{($[[≈]]_-^{[[⇔]]}$)}


% Γ ; Φ ⊢ v ⇒ iP 
\renewcommand{\ottdruleDTVarSynName}[0]{(Var$^{[[⇒]]}$)}
\renewcommand{\ottdruleDTPAnnotSynName}[0]{(ann$_+^{[[⇒]]}$)}

% Γ ; Φ ⊢ v ⇐ iP 
\renewcommand{\ottdruleDTPSubName}[0]{(SUB$_{+}$)}

% Γ ; Φ ⊢ v ⇔ iP 
\renewcommand{\ottdruleDTThunkChkSynName}[0]{($\{\}^{[[⇔]]}$)}
\renewcommand{\ottdruleDTPEquivChkSynName}[0]{($[[≈]]_+^{[[⇔]]}$)}

% Γ ; Φ ⊢ iN ● args ⇒> iM (Bidir)
\renewcommand{\ottdruleDTEmptyAppBidirName}[0]{($\emptyset_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleDTArrowAppBidirName}[0]{($\rightarrow_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleDTForallAppBidirName}[0]{($\forall_{[[●]][[⇒>]]}^{\text{inf}}$)}



% Γ ; Φ ⊨ v : iP  
\renewcommand{\ottdruleATVarName}[0]{(Var$^{\text{inf}}$)}
\renewcommand{\ottdruleATThunkName}[0]{($\{\}^{\text{inf}}$)}
\renewcommand{\ottdruleATPAnnotName}[0]{(ann$_+^{\text{inf}}$)}

% Γ ; Φ ⊨ c : iN 
\renewcommand{\ottdruleATtLamName}[0]{($\lambda^{\text{inf}}$)}
\renewcommand{\ottdruleATTLamName}[0]{($\Lambda^{\text{inf}}$)}
\renewcommand{\ottdruleATReturnName}[0]{(ret$^{\text{inf}}$)}
\renewcommand{\ottdruleATVarLetName}[0]{(let$^{\text{inf}}$)}
\renewcommand{\ottdruleATCVarLetName}[0]{(let$_{\text{c}}^{\text{inf}}$)}
\renewcommand{\ottdruleATAppLetName}[0]{(let$_@^{\text{inf}}$)}
\renewcommand{\ottdruleATAppLetAnnName}[0]{(let$_{:@}^{\text{inf}}$)}
\renewcommand{\ottdruleATUnpackName}[0]{(let$_{\exists}^{\text{inf}}$)}
\renewcommand{\ottdruleATNAnnotName}[0]{(ann$_-^{\text{inf}}$)}

% Γ ; Φ ; Θ1 ⊨ uN ● args ⇒> uM ⫤ Θ2 ; SC 
\renewcommand{\ottdruleATEmptyAppName}[0]{($\emptyset_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleATArrowAppName}[0]{($\rightarrow_{[[●]][[⇒>]]}^{\text{inf}}$)}
\renewcommand{\ottdruleATForallAppName}[0]{($\forall_{[[●]][[⇒>]]}^{\text{inf}}$)}



% Γ ; Φ ⊨ c ⇒ iN 
\renewcommand{\ottdruleATtLamSynName}[0]{($\lambda^{[[⇒]]}$)}
\renewcommand{\ottdruleATTLamSynName}[0]{($\Lambda^{[[⇒]]}$)}
\renewcommand{\ottdruleATNAnnotSynName}[0]{(ann$_-^{[[⇒]]}$)}

% Γ ; Φ ⊨ c ⇐ iN 
\renewcommand{\ottdruleATtLamChkName}[0]{($\lambda^{[[⇐]]}$)}
\renewcommand{\ottdruleATNSubName}[0]{(SUB$_{-}$)}

% Γ ; Φ ⊨ c ⇔ iN 
\renewcommand{\ottdruleATReturnChkSynName}[0]{(ret$^{[[⇔]]}$)}
\renewcommand{\ottdruleATVarLetChkSynName}[0]{(let$^{[[⇔]]}$)}
\renewcommand{\ottdruleATAppLetChkSynName}[0]{(let$_@^{[[⇔]]}$)}
\renewcommand{\ottdruleATAppLetAnnChkSynName}[0]{(let$_{:@}^{[[⇔]]}$)}
\renewcommand{\ottdruleATUnpackChkSynName}[0]{(let$_{\exists}^{[[⇔]]}$)}


% (Bidir)
% Γ ; Φ ⊨ v ⇒ iP 
\renewcommand{\ottdruleATVarSynName}[0]{(Var$^{[[⇒]]}$)}
\renewcommand{\ottdruleATPAnnotSynName}[0]{(ann$_+^{[[⇒]]}$)}

% Γ ; Φ ⊨ v ⇐ iP 
\renewcommand{\ottdruleATPSubName}[0]{(SUB$_{+}$)}

% Γ ; Φ ⊨ v ⇔ iP 
\renewcommand{\ottdruleATThunkChkSynName}[0]{($\{\}^{[[⇔]]}$)}

% Γ ; Φ ; Θ1 ⊨ uN ● args ⇒> uM ⫤ Θ2 ; SC 
\renewcommand{\ottdruleATEmptyAppBidirName}[0]{($\emptyset^{[[●]][[⇒>]]}$)}
\renewcommand{\ottdruleATArrowAppBidirSName}[0]{($\rightarrow^{[[●]][[⇒>]]}$)}
\renewcommand{\ottdruleATArrowAppBidirName}[0]{($\rightarrow^{[[●]][[⇒>]]}$)}
\renewcommand{\ottdruleATForallAppBidirName}[0]{($\forall^{[[●]][[⇒>]]}$)}


% scE1 singular with iP
\renewcommand{\ottdruleSINGPEqName}[0]{($[[≈]]_{+}^{\text{sing}}$)}
\renewcommand{\ottdruleSINGSupVarName}[0]{($[[:≥]]\alpha^{\text{sing}}$)}
\renewcommand{\ottdruleSINGSupShiftName}[0]{($[[:≥]][[↓]]^{\text{sing}}$)}

% scE1 singular with iN
\renewcommand{\ottdruleSINGNEqName}[0]{($[[≈]]_{-}^{\text{sing}}$)}

% Γ ⊢ uP SC minby uσ 
\renewcommand{\ottdruleSINGPUvarName}[0]{(UVar$^{\text{min}}$)}
\renewcommand{\ottdruleSINGExistsName}[0]{($[[∃]]^{\text{min}}$)}
\renewcommand{\ottdruleSINGSingName}[0]{(sing$^{\text{min}}$)}

% fΓ ; fΦ ⊢ ft : fT 
\renewcommand{\ottdruleSFtyVarName}[0]{(Var$^{\mathsf{F}}$)}
\renewcommand{\ottdruleSFtytLamName}[0]{($\lambda^{\mathsf{F}}$)}
\renewcommand{\ottdruleSFtyTLamName}[0]{($\Lambda^{\mathsf{F}}$)}
\renewcommand{\ottdruleSFtyAppName}[0]{($\mathsf{App}^{\mathsf{F}}$)}
\renewcommand{\ottdruleSFtyTAppName}[0]{($\mathsf{TApp}^{\mathsf{F}}$)}
\renewcommand{\ottdruleSFtyAUnpackName}[0]{($\mathsf{Unpack}^{\mathsf{F}}$)}
\renewcommand{\ottdruleSFtyAPackName}[0]{($\mathsf{Pack}^{\mathsf{F}}$)}
\renewcommand{\ottdruleSFtyALetName}[0]{($\mathsf{Let}^{\mathsf{F}}$)}

% Γ ⊢ iN ≤ iM ⤳ ft
\renewcommand{\ottdruleELNVarName}[0]{(Var$_{[[≤]]}^{\leadsto}$)}
\renewcommand{\ottdruleELPVarName}[0]{(Var$_{[[≥]]}^{\leadsto}$)}
\renewcommand{\ottdruleELShiftUName}[0]{($\uparrow_{[[≤]]}^{\leadsto}$)}
\renewcommand{\ottdruleELShiftDName}[0]{($\downarrow_{[[≥]]}^{\leadsto}$)}
\renewcommand{\ottdruleELExistsName}[0]{($\exists_{[[≥]]}^{\leadsto}$)}
\renewcommand{\ottdruleELForallName}[0]{($\forall_{[[≤]]}^{\leadsto}$)}
\renewcommand{\ottdruleELArrowName}[0]{($\rightarrow_{[[≤]]}^{\leadsto}$)}

% Γ ; Φ ⊢ v : iP  ⤳  ft 
\renewcommand{\ottdruleTELVarName}[0]{(Var$^{\PMelab}$)}
\renewcommand{\ottdruleTELThunkName}[0]{($\{\}^{\PMelab}$)}
\renewcommand{\ottdruleTELPAnnotName}[0]{(ann$_+^{\PMelab}$)}
\renewcommand{\ottdruleTELPEquivName}[0]{($[[≈]]_+^{\PMelab}$)}
\renewcommand{\ottdruleTELtLamName}[0]{($\lambda^{\PMelab}$)}
\renewcommand{\ottdruleTELTLamName}[0]{($\Lambda^{\PMelab}$)}
\renewcommand{\ottdruleTELReturnName}[0]{(ret$^{\PMelab}$)}
\renewcommand{\ottdruleTELCVarLetName}[0]{(let$_{\text{c}}^{\PMelab}$)}
\renewcommand{\ottdruleTELVarLetName}[0]{(let$^{\PMelab}$)}
\renewcommand{\ottdruleTELAppLetName}[0]{(let$_@^{\PMelab}$)}
\renewcommand{\ottdruleTELAppLetAnnName}[0]{(let$_{:@}^{\PMelab}$)}
\renewcommand{\ottdruleTELUnpackName}[0]{(let$_{\exists}^{\PMelab}$)}
\renewcommand{\ottdruleTELNAnnotName}[0]{(ann$_-^{\PMelab}$)}
\renewcommand{\ottdruleTELNEquivName}[0]{($[[≈]]_-^{\PMelab}$)}
\renewcommand{\ottdruleTELEmptyAppName}[0]{($\emptyset_{[[●]][[⇒>]]}^{\PMelab}$)}
\renewcommand{\ottdruleTELArrowAppName}[0]{($\rightarrow_{[[●]][[⇒>]]}^{\PMelab}$)}
\renewcommand{\ottdruleTELForallAppName}[0]{($\forall_{[[●]][[⇒>]]}^{\PMelab}$)}


\renewcommand{\ottdruleELVarName}[0]{(Var$^{\elabPM}$)}
\renewcommand{\ottdruleELtLamName}[0]{($\lambda^{\elabPM}$)}
\renewcommand{\ottdruleELTLamName}[0]{($\Lambda^{\elabPM}$)}
\renewcommand{\ottdruleELAppName}[0]{($\mathsf{App}^{\elabPM}$)}
\renewcommand{\ottdruleELTAppName}[0]{($\mathsf{TApp}^{\elabPM}$)}