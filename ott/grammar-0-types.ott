embed {{ tex-preamble

\usepackage{esvect}


% https://tex.stackexchange.com/questions/33401/a-version-of-colorbox-that-works-inside-math-environments
\setlength{\fboxsep}{1pt}
\newcommand{\ngbox}[1]{\mathchoice%
  {\colorbox{black!8}{$\displaystyle      \mathit{ #1 } $} }%
  {\colorbox{black!8}{$\textstyle         \mathit{ #1 } $} }%
  {\colorbox{black!8}{$\scriptstyle       \mathit{ #1 } $} }%
  {\colorbox{black!8}{$\scriptscriptstyle \mathit{ #1 } $} } }%

}}

metavar a {{ tex \alpha }}, b {{ tex \beta }}, α {{ tex \alpha }}, β {{ tex \beta }},
 γ {{ tex \gamma }},  δ {{ tex \delta }} ::= {{ com type variables }}

indexvar n , m, i , j ::= {{ com index variables }}


grammar

coh {{ tex n }}, mcoh {{ tex m }} :: 'n_' ::= {{ com cohort index }}
    | Z     :: :: Zero {{ tex 0 }}
    | S coh :: :: Succ {{ tex [[coh]]+1 }}


grammar

pa {{ tex \alpha^{+} }},
pb {{ tex \beta^{+} }},
pc {{ tex \gamma^{+} }},
pd {{ tex \delta^{+} }} 
:: 'pa_' ::= {{ com positive variable }}
   | a ⁺       :: :: Var {{ tex [[a]]^{+} }}
   | a ⁺ : coh :: :: VarCoh {{ tex [[a]]^{+ [[coh]] } }}
   | pnb       :: :: PNVar

na {{ tex \alpha^{-} }},
nb {{ tex \beta^{-} }},
nc {{ tex \gamma^{-} }},
nd {{ tex \delta^{-} }}
:: 'na_' ::= {{ com negative variable }}
   | a ⁻       :: :: Var {{ tex [[a]]^{-} }}
   | a ⁻ : coh :: :: VarCoh {{ tex [[a]]^{- [[coh]] } }}
   | pna       :: :: PNVar

pna {{ tex \alpha^{\pm} }},
pnb {{ tex \beta^{\pm} }}
:: 'pna_' ::= {{ com positive or negative variable }}
   | a ±       :: :: Var {{ tex [[a]]^{\pm} }}
   | a ± : coh :: :: VarCoh {{ tex [[a]]^{\pm [[coh]] } }}



grammar

s {{ tex \sigma }}, σ {{ tex \sigma }}  :: 's_' ::= {{ com substitution }}
   | ·                    ::   :: Empty
   | id                   ::   :: Id {{ tex \mathsf{id} }}
   | P / pa               ::   :: PosSub
   | N / na               ::   :: NegSub
   | iPs / pas            ::   :: PosSubs 
   | iNs / nas            ::   :: NegSubs
   | pmas / pas           ::   :: PosMSubs
   | nmas / nas           ::   :: NegMSubs
   | puas / pas           ::   :: PosUSubs
   | nuas / nas           ::   :: NegUSubs
   | nas / nuas           ::   :: NegFromUSubs
   | Sub μ                ::   :: FromMoving {{ tex [[μ]] }}
   % | Sub us               ::   :: FromUs {{ tex [[us]] }}
   | σ1 ○ σ2              ::   :: Compose
   | σ1 <=< σ2            ::   :: ComposeM
   | ordVars1 / ordVars2  ::   :: VarSubs
   | ( σ )                :: S :: paren
   | </ si // , // i />   ::   :: concat  {{ com concatenate }}

scE {{ tex e }} :: 'scE_' ::= {{ com entry of a subtyping constraint }}
   | pua :≈ iP            ::   :: PEq {{ tex [[pua]] :\approx   [[iP]] }}
   | nua :≈ iN            ::   :: NEq {{ tex [[nua]] :\approx   [[iN]] }}
   | pua :≥ iP            ::   :: Sup {{ tex [[pua]] :\geqslant [[iP]] }}
   | ( scE )              :: S :: paren
   | SC ( nua )           :: M :: NSelect

ucE  {{ tex e }} :: 'ucE_' ::= {{ com entry of a unification constraint }}
   | pua :≈ iP            :: :: PEq {{ tex [[pua]] :\approx   [[iP]] }}
   | nua :≈ iN            :: :: NEq {{ tex [[nua]] :\approx   [[iN]] }}
   | ( ucE )              :: S :: paren


UC :: 'UC_' ::= {{ com unification constraint }}
   | ·                   ::   :: Empty
   | ucE                 ::   :: Entry
   | UC \ varset         ::   :: Exclude
   | UC | varset         ::   :: Restr
   | UC1 ∪ UC2           ::   :: Union
   | </ UCi // , // i /> ::   :: concat  {{ com concatenate }}
   | ( UC )              :: S :: paren

SC :: 'SC_' ::= {{ com subtyping constraint }}
   | ·                   ::   :: Empty
   | scE                 ::   :: Entry
   | SC \ varset         ::   :: Exclude
   | SC | varset         ::   :: Restr
   | SC1 ∪ SC2           ::   :: Union
   | lift UC             ::   :: Lift    {{ tex [[UC]] }}
   | </ SCi // , // i /> ::   :: concat  {{ com concatenate }}
   | ( SC )              :: S :: paren

us {{ tex \widehat{\sigma} }}, uσ {{ tex \widehat{\sigma} }} :: 'us_' ::= {{ com unification substitution }}
   | ·                   ::   :: Empty
   | iP / pua            ::   :: PosSub
   | iN / nua            ::   :: NegSub
   | iPs / puas          ::   :: PosSubs 
   | iNs / nuas          ::   :: NegSubs
   | ( uσ )               :: S :: paren
   | uσ1 ○ uσ2           ::   :: Compose
   | </ uσi // , // i />  ::   :: concat  {{ com concatenate }}

grammar

aus {{ tex \widehat{\tau} }}, ausr {{ tex \widehat{\rho} }} :: 'aus_' ::= {{ com anti-unification substitution }}
   | ·                    ::   :: Empty
   | nua :≈ iN            ::   :: NSol  {{ tex [[nua]] :\approx [[iN]] }}
   | nua :≈ uN            ::   :: NuSol {{ tex [[nua]] :\approx [[uN]] }}
   | nas / nuas           ::   :: NegFromUSubs
   | iNs / nuas           ::   :: Neg
   | aus1 ∪ aus2          ::   :: Union
   | </ ausi // , // i /> ::   :: concat  {{ com concatenate }}
   | ( aus )              :: S :: paren

grammar

P, Q, R :: 'P_' ::= {{ com positive types }}
   | pa       ::   :: Var
   | ↓ N      ::   :: Shift
   | ∃ na . P ::   :: Exists
   | [ s ] P  :: M :: AppSub 

N, M, K :: 'N_' ::= {{ com negative types }}
   | na       ::   :: Var
   | ↑ P      ::   :: Shift
   | ∀ pa . N ::   :: Forall
   | P → N    ::   :: Fun
   | [ s ] N  :: M :: AppSub 

grammar

pas {{ tex \vv{ \alpha^{+} } }},
pbs {{ tex \vv{ \beta^{+} } }},
pcs {{ tex \vv{ \gamma^{+} } }},
pds {{ tex \vv{ \delta^{+} } }}
:: 'pas_' ::= {{ com positive variable list }}
   | ·                    ::   :: empty   {{ com empty list }}
   | pa                   ::   :: Var     {{ com a variable }}
   | pa *                 ::   :: Vars    {{ com a variable }}
                                          {{ tex \vv{[[pa]]} }}
   | </ pasi // , // i /> ::   :: concat  {{ com concatenate lists }}

nas {{ tex \vv{ \alpha^{-} } }},
nbs {{ tex \vv{ \beta^{-} } }},
ncs {{ tex \vv{ \gamma^{-} } }},
nds {{ tex \vv{ \delta^{-} } }}
:: 'nas_' ::= {{ com negative variables }}
   | ·                    ::   :: empty   {{ com empty list }}
   | na                   ::   :: Var     {{ com a variable }}
   | na *                 ::   :: Vars    {{ com variables }}
                                          {{ tex \vv{[[na]]} }}
   | </ nasi // , // i /> ::   :: concat  {{ com concatenate lists }}

pnas {{ tex \vv{ \alpha^{\pm} } }},
pnbs {{ tex \vv{ \beta^{\pm} } }},
pncs {{ tex \vv{ \gamma^{\pm} } }},
pnds {{ tex \vv{ \delta^{\pm} } }}
:: 'pnas_' ::= {{ com positive or negative variable list }}
   | ·                     ::   :: empty   {{ com empty list }}
   | pna                   ::   :: Var     {{ com a variable }}
   | pna *                 ::   :: Vars    {{ com variables }}
                                           {{ tex \vv{[[pa]]} }}
   | </ pnasi // , // i /> ::   :: concat  {{ com concatenate lists }}


iP {{ tex P }}, iQ {{ tex Q }}, iR {{ tex R }} :: 'iP_' ::= {{ com multi-quantified positive types }}
   | pa         ::   :: Var
   | ↓ iN       ::   :: Shift
   | ∃ nas . iP ::   :: Exists 
   | [ σ ]  iP  :: M :: AppSub  
   | [ aus ] uP :: M :: AppAUSub  
   | [ uσ ] uP  :: M :: AppUSub  
   | [ mu ] iP  :: M :: AppMoving 
   | ( iP )     :: S :: Paren

iN {{ tex N }}, iM {{ tex M }}, iK {{ tex K }} :: 'iN_' ::= {{ com multi-quantified negative types }}
   | na          ::   :: Var
   | ↑ iP        ::   :: Shift
   | iP → iN     ::   :: Fun
   | ∀ pas . iN  ::   :: Forall 
   | [ σ ] iN    :: M :: AppSub 
   | [ aus ] uN  :: M :: AppAUSub
   | [ mu ] iN   :: M :: AppMoving
   | [ uσ ] uN   :: M :: AppUSub  
   | ( iN )      :: S :: Paren


iPs {{ tex \vv{ P } }},
iQs {{ tex \vv{ Q } }}
:: 'iPs_' ::= {{ com list of positive types }}
   | ·                    ::   :: empty   {{ com empty list }}
   | iP                   ::   :: Var     {{ com a singel type }}
   | [ s ] iPs            :: M :: AppSub
   | </ iPsi // , // i /> ::   :: concat  {{ com concatenate lists }}
   | ( iPs )              :: S :: paren

iNs {{ tex \vv{ N } }},
iMs {{ tex \vv{ M } }}
:: 'iNs_' ::= {{ com list of negative types }}
   | ·                    ::   :: empty   {{ com empty list }}
   | iN                   ::   :: Var     {{ com a singel type }}
   | [ s ] iNs            :: M :: AppSub
   | </ iNsi // , // i /> ::   :: concat  {{ com concatenate lists }}
   | ( iNs )              :: S :: paren


grammar

G {{ tex \Gamma }}, Δ {{ tex \Delta }}, Γ {{ tex \Gamma }} :: DT_Ctxt ::= {{ com declarative type context }}
    | ·                  ::   :: empty   {{ com empty context }}
    % | varset             ::   :: nvar     {{ com a negative variable }}
    | pas                ::   :: PList   {{ com list of variables }}
    | nas                ::   :: NList   {{ com list of variables }}
    | pnas               ::   :: PNList  {{ com list of variables }}
    | Ord varset         ::   :: fromset {{ tex [[varset]] }}
    | </ Gi // , // i /> ::   :: concat  {{ com concatenate contexts }}
    | ( G )              :: S :: paren
    | Θ ( pua )          :: M :: pfromUC 
    | Θ ( nua )          :: M :: nfromUC 

grammar

T {{ tex \Theta }}, Θ {{ tex \Theta }}:: U_Ctxt ::= {{ com algorithmic variable context }}
    | ·                  ::   :: empty     {{ com empty context }}
    | ordVars [ Δ ]      ::   :: FromVList {{ com from an ordered list of variables }}
                                           {{ tex [[ordVars]] \{[[Δ]]\} }}
    | pua * [ Δ ]        ::   :: FromVarS  {{ com from a variable to a list }}
                                           {{ tex \vv{ [[pua]] \{[[Δ]]\} } }}
    | </ Θi // , // i /> ::   :: concat    {{ com concatenate contexts }}
    | ( Θ )              :: S :: paren
    | Θ | varset         ::   :: restr   {{ com leave only those variables that are in the set }}
                                         {{ tex [[Θ]]|_{[[varset]]} }}
    | Θ1 ∪ Θ2            ::   :: union
grammar

Xi {{ tex \Xi }}, Ξ {{ tex \Xi }} :: AU_Ctxt ::= {{ com anti-unification type variable context }}
    | ·                  ::   :: empty   {{ com empty context }}
    | puas               ::   :: PAUList {{ com list of positive variables }}
    | nuas               ::   :: NAUList {{ com list of negative variables }}
    | uv uN              ::   :: Nuv       {{ com unification variables }}
    | uv uP              ::   :: Puv       {{ com unification variables }}
    | </ Ξi // , // i /> ::   :: concat  {{ com concatenate contexts }}
    | ( Ξ )              :: S :: paren
    | Ξ1 ∪ Ξ2            ::   :: union
    | Ξ1 ∩ Ξ2            ::   :: intersect

                                       % {{ com context containing only negative uvars }}
grammar

ordVars {{ tex \vv{ \alpha } }}, ordVarsb {{ tex \vv{ \beta } }} :: OrdVars ::= {{ com ordered positive or negative variables }}
    | ·                         ::   :: empty     {{ com empty list }}
    | pas                       ::   :: PList     {{ com list of variables }}
    | nas                       ::   :: NList     {{ com list of variables }}
    | pnas                      ::   :: PNList    {{ com list of variables }}
    | puas                      ::   :: PUList    {{ com list of variables }}
    | nuas                      ::   :: NUList    {{ com list of variables }}
    | ordVars1 \ varset         ::   :: Setminus  {{ com setminus }}
    | G                         ::   :: Cntxt     {{ com context }}
    | Ord varset                ::   :: fromset   {{ tex [[varset]] }}
    | </ ordVarsi // , // i />  ::   :: concat    {{ com concatenate contexts }}
    | ( ordVars )               :: S :: paren     {{ com parenthesis }}
    | [ mu ] ordVars            :: M :: moving    {{ com apply moving to list }}


grammar

varset {{ tex \textit{vars} }} :: Varset ::= {{ com set of variables }}
    | ∅                  ::   :: emptyset  {{ com empty set }}
    | fv iP              ::   :: Pfv       {{ com free variables }}
    | fv iN              ::   :: Nfv       {{ com free variables }}
    | fv imP             ::   :: mPfv      {{ com free variables }}
    | fv imN             ::   :: mNfv      {{ com free variables }}
    | varset1 ∩ varset2  ::   :: intersect {{ com set intersection }}
    | varset1 ∪ varset2  ::   :: union     {{ com set union }}
    | varset1 \ varset2  ::   :: setminus  {{ com set complement }}
    | mv imP             ::   :: Pmv       {{ com movable variables }}
    | mv imN             ::   :: Nmv       {{ com movable variables }}
    | fv uN              ::   :: uNfv      {{ com free variables }}
    | fv uP              ::   :: uPfv      {{ com free variables }}
    | ( varset )         :: S :: paren     {{ com parenthesis }}
    | { ordVars }        ::   :: OrdVars   {{ com ordered list of variables }}
                                           {{ tex [[ordVars]] }}
    | [ mu ] varset      :: M :: moving    {{ com apply moving to varset }}
    | Ξ                  ::   :: AU_Ctxt   {{ com anti-unification context }}
grammar

mu {{ tex \mu }}, μ {{ tex \mu }}:: Mu ::= 
    | ·                   ::   :: empty   {{ com empty moving }}
    | pma1 ↦ pma2         ::   :: Psingle {{ com Positive unit substitution }}
    | nma1 ↦ nma2         ::   :: Nsingle {{ com Positive unit substitution }}
    | mu1 ∪ mu2           :: M :: Union   {{ com Set-like union of movings }} 
    | mu1 ○ mu2           :: M :: Compose {{ com Composition }} 
    | </ mui // , // i /> ::   :: concat  {{ com concatenate movings }}
    | mu |_ varset        :: M :: restr   {{ com restriction on a set }} 
                                          {{ tex [[mu]]|_{[[varset]]}  }} 
    | mu -1               :: M :: inv     {{ com inversion }} 
                                          {{ tex [[mu]]^{-1} }} 


% pma {{ tex \widetilde{\alpha}^{+} }} :: pma_ ::= {{ com positive movable variable }}
%     | a + : coh :: :: Var {{ tex \widetilde{[[a]]}^{+ [[coh]] } }}


% nma {{ tex \widetilde{\alpha}^{-} }} :: nma_ ::= {{ com negative movable variable }}
%     | a - : coh :: :: Var {{ tex \widetilde{[[a]]}^{- [[coh]] } }}


% pmas {{ tex \vv{ \widetilde{ \alpha^{+} } } }},
% pmbs {{ tex \vv{ \widetilde{ \beta^{+}  } } }}
% :: 'pmas_' ::= {{ com positive movable variable list }}
%    | ·                     ::   :: empty    {{ com empty list }}
%    | pma                   ::   :: Var      {{ com a variable }}
%    % | pas : coh             ::   :: FromVars {{ com from a list of non-movable variables }}
%    %                                          {{ tex \vv{ \widetilde{ [[pas]]^{+[[coh]]} } } }}
%    | a + * : coh            ::   :: FromVar  {{ com from a non-movable variable }}
%                                             {{ tex \vv{ \widetilde{ [[a]]^{+[[coh]]} } } }}
%    | </ pmasi // , // i /> ::   :: concat   {{ com concatenate lists }}

% nmas {{ tex \vv{ \widetilde{ \alpha^{-} } } }},
% nmbs {{ tex \vv{ \widetilde{ \beta^{-}  } } }}
% :: 'nmas_' ::= {{ com negatiive movable variable list }}
%    | ·                     ::   :: empty    {{ com empty list }}
%    | nma                   ::   :: Var      {{ com a variable }}
%    % | nas : coh             ::   :: FromVars {{ com transofmed non-movable variables }}
%    %                                          {{ tex \vv{ \widetilde{ [[nas]]^{-[[coh]]} } } }}
%    | a - * : coh            ::   :: FromVar  {{ com from a non-movable variable }}
%                                             {{ tex \vv{ \widetilde{ [[a]]^{-[[coh]]} } } }}
%    | </ nmasi // , // i /> ::   :: concat   {{ com concatenate lists }}


% imP {{ tex P }}, imQ {{ tex Q }}:: 'imP_' ::= {{ com multi-quantified positive types with movable variables }}
%    | pa          ::   :: Var
%    | pma         ::   :: MovVar
%    | ↓ imN       ::   :: Shift
%    | ∃ nas . imP ::   :: Exists
%    | [ s ] imP   :: M :: AppSub  
%    | [ mu ] imP  :: M :: AppMoving 

% imN {{ tex N }}, imM {{ tex M }} :: 'imN_' ::= {{ com multi-quantified negative types with movable variables }}
%    | na          ::   :: Var
%    | nma         ::   :: MovVar
%    | ↑ imP       ::   :: Shift
%    | imP → imN    ::   :: Fun
%    | ∀ pas . imN ::   :: Forall
%    | [ s ] imN   :: M :: AppSub 
%    | [ mu ] imN  :: M :: AppMoving



grammar

pnua {{ tex \widehat{\alpha}^{\pm} }} :: pnua_ ::= {{ com positive/negative unification variable }}
    | a ̂ ±        :: :: Var {{ tex \widehat{[[a]]}^{\pm} }}
    %| a ̂ ± [ Δ ]  :: :: AnnotVar {{ tex \widehat{[[a]]}^{\pm}\{ [[Δ]] \} }}

pua {{ tex \widehat{\alpha}^{+} }} :: pua_ ::= {{ com positive unification variable }}
    | a ̂ ⁺        :: :: Var {{ tex \widehat{[[a]]}^{+} }}
    | pua  [ Δ ]  :: :: AnnotVar {{ tex [[pua]]\{ [[Δ]] \} }}
    | pnua        :: :: PN

nua {{ tex \widehat{\alpha}^{-} }},
nub {{ tex \widehat{\beta}^{-} }}
:: nua_ ::= {{ com negative unification variable }}
    | a ̂ ⁻               :: :: Var {{ tex \widehat{[[a]]}^{-} }}
    | a ̂ ⁻ _ { iN , iM } :: :: VarIdxd {{ tex \widehat{[[a]]}^{-}_{\{ [[iN]], [[iM]] \} } }}
    | nua [ Δ ]          :: :: AnnotVar {{ tex [[nua]]\{ [[Δ]] \} }}
    | pnua               :: :: PN

puas {{ tex \vv{ \widetilde{ \alpha^{+} } } }},
pubs {{ tex \vv{ \widetilde{ \beta^{+}  } } }}
:: 'puas_' ::= {{ com positive unification variable list }}
   | ·                     ::   :: empty    {{ com empty list }}
   | pua                   ::   :: Var      {{ com a variable }}
   | pua *                 ::   :: FromVar  {{ com from a normal variable, context unspecified }}
                                            {{ tex \vv{ [[pua]] } }}
   | </ puasi // , // i /> ::   :: concat   {{ com concatenate lists }}

nuas {{ tex \vv{ \widehat{ \alpha^{-} } } }},
nubs {{ tex \vv{ \widehat{ \beta^{-}  } } }}
:: 'nuas_' ::= {{ com negative unification variable list }}
   | ·                     ::   :: empty    {{ com empty list }}
   | nua                   ::   :: Var      {{ com a variable }}
   | ToList Ξ              ::   :: Ctxt     {{ com from an antiunification context }}
                                            {{ tex [[Ξ]] }}
   | nua * [ Δ ]           ::   :: FromVarC {{ com from a normal variable }}
                                            {{ tex \vv{ [[nua]] \{[[Δ]]\} } }}
   | nua *                 ::   :: FromVar  {{ com from a normal variable, context unspecified }}
                                            {{ tex \vv{ [[nua]]  } }}
   | </ nuasi // , // i /> ::   :: concat   {{ com concatenate lists }}



uP {{ tex \ngbox{P} }}, uQ {{ tex \ngbox{Q} }}:: 'uP_' ::= {{ com a positive algorithmic type (potentially with metavariables) }}
                                                            {{ tex \ngbox{[[uP]]} }} 
   | pua           ::   :: UnifVar 
   | pa            ::   :: Var 
   | ↓ uN          ::   :: Shift
   | ∃ nas . uP    ::   :: Exists
   | [ s ] uP      :: M :: AppSub  
   | [ aus ] uP    :: M :: AppAUSub  
   | [ mu ] uP     :: M :: AppMoving 
   | [ uσ ] uP     :: M :: AppUSub  
   | [ nuas / nas ] iP :: M :: AppAUNSub
   | ( uP )        :: S :: Paren

uN {{ tex \ngbox{N} }}, uM {{ tex \ngbox{M} }} :: 'uN_' ::= {{ com a negative algorithmic type (potentially with metavariables) }}
                                                             {{ tex \ngbox{[[uN]]} }}
   | nua            ::   :: UnifVar
   | na             ::   :: Var
   | ↑ uP           ::   :: Shift
   | uP → uN        ::   :: Fun
   | ∀ pas . uN     ::   :: Forall
   | [ s ] uN       :: M :: AppSub 
   | [ aus ] uN     :: M :: AppAUSub
   | [ mu ] uN      :: M :: AppMoving
   | [ uσ ] uN      :: M :: AppUSub
   | [ nuas / nas ] iN :: M :: AppAUNSub
   | ( uN )         :: S :: Paren


auSol :: 'auSOL_' ::=
   | ( Ξ , uQ , aus1 , aus2 ) :: :: PSol
   | ( Ξ , uN , aus1 , aus2 ) :: :: NSol

terminals :: 'terminals_' ::=
  | ∃  :: :: exists    {{ tex \exists }}
  | ∀  :: :: forall    {{ tex \forall }}
  | ↑  :: :: upShift   {{ tex \mathord{\uparrow} }}
  | ↓  :: :: downShift {{ tex \mathord{\downarrow} }}
  | →  :: :: funArrow  {{ tex \rightarrow }}
  | ↔  :: :: bijArrow  {{ tex \leftrightarrow }}
  | ∊  :: :: inSet     {{ tex \in }}
  | ∉  :: :: notInSet  {{ tex \notin }}
  | ·  :: :: cDot      {{ tex \cdot }}
  | ⊢  :: :: vdash     {{ tex \vdash }}
  | ≤  :: :: subtype   {{ tex \leqslant }}
  | ≥  :: :: supertype {{ tex \geqslant }}
  | ≈  :: :: equiv     {{ tex \simeq }}
  | ∪  :: :: union     {{ tex \cup }}
  | ∩  :: :: intersect {{ tex \cap }}
  | \  :: :: setminus  {{ tex \setminus }}
  | ⊆  :: :: subset    {{ tex \subseteq }}
  | ↦  :: :: mapsto    {{ tex \mapsto }}
  | ≈u :: :: unify      {{ tex \overset{u}{\simeq} }}
  | ≈au :: :: antiunify {{ tex \overset{a}{\simeq} }}
  | ∅ :: :: empty      {{ tex \emptyset }}
  | ○ :: :: compose    {{ tex \circ }}
  | ⇒ :: :: implies    {{ tex \Rightarrow }}
  % | ≈a :: :: antiunify {{ tex \overset{g}{\simeq} }}
  | ⊨  :: :: vDash     {{ tex \vDash }}
  | ⫤  :: :: Dashv     {{ tex \Dashv }}
  % | ⊫  :: :: VDash     {{ tex \mathcolor{\ccolor}{\VDash} }}
  % | ⫥  :: :: DashV     {{ tex \mathcolor{\ccolor}{\DashV} }}
  | ≠  :: :: neq       {{ tex \neq }}
  % | ≡  :: :: equiv     {{ tex \mathcolor{\rcolor}{\equiv} }}
  | ≡n  :: :: equivn   {{ tex \equiv_{n} }}
  | ∨  :: :: LUB       {{ tex \vee }}
  | ⇓ :: :: norm       {{ tex \Downarrow }}
  | :≥ :: :: solGeq    {{ tex :[[≥]] }}
  | :≈ :: :: solEq     {{ tex :[[≈]] }}
  | Λ    :: :: bigLam    {{ tex \Lambda }}
  | λ    :: :: lam       {{ tex \lambda }}
  | let∃ :: :: letExists {{ tex \ottkw{let}^{\exists} }}
  | ●    :: :: bullet    {{ tex \bullet }}
  | ⇒>   :: :: spinInf   {{ tex \Rightarrow \hspace{-3pt} > }}
  | <=<  :: :: compM     {{ tex \mathord{< \hspace{-5.3pt} = \hspace{-4.2pt} <} }}



% subrules
%   iP <:: imP
%   iN <:: imN
% subrules
%   iP <:: uP  
%   iN <:: uN  


funs
  LUBF ::=
fun
  iP1 ∨ iP2 :: iQ :: LUB 
by

fun ord varset in uP :: ordVars :: uPOrd by
fun ord varset in uN :: ordVars :: uNOrd by
fun ord varset in iP :: ordVars :: NOrd by
fun ord varset in iN :: ordVars :: POrd by

fun nf ( iN' )  :: iN :: NNf by
fun nf ( iP' )  :: iP :: PNf by
fun nf ( uN' )  :: uN :: uNNf by
fun nf ( uP' )  :: uP :: uPNf by
fun nf ( iNs' ) :: iNs :: uNsNf by
fun nf ( iPs' ) :: iPs :: uPsNf by
fun nf ( σ' )   :: σ :: SubNf by
fun nf ( uσ' )   :: uσ :: USubNf by
fun nf ( μ' )   :: μ :: Movnf by

fun σ'   | varset :: σ :: Restr {{ tex [[σ']]|_{[[varset]]} }} by 
fun uσ'  | varset :: uσ :: USRestr {{ tex [[uσ']]|_{[[varset]]} }} by 
fun aus' | varset :: aus :: AURestr {{ tex [[aus']]|_{[[varset]]} }} by
fun Xi'  | varset :: Xi :: XiRestr {{ tex [[Xi']]|_{[[varset]]} }} by
fun SC'  | varset :: SC :: SCRestr {{ tex [[SC']]|_{[[varset]]} }} by
fun UC'  | varset :: UC :: UCRestr {{ tex [[UC']]|_{[[varset]]} }} by

fun
   ucE1 & ucE2 :: ucE :: UCEM {{ tex [[ucE1]] ~ \& ~ [[ucE2]] }}
by

fun
   scE1 & scE2 :: scE :: SCEM {{ tex [[scE1]] ~ \& ~ [[scE2]] }}
by


fun
   UC1 & UC2 :: UC :: UCM {{ tex [[UC1]] ~ \& ~[[UC2]] }}
by

fun 
   UC1 ∪ UC2 :: UC :: UCUnion {{ tex [[UC1]] \cup [[UC2]] }}
by 

fun
   Γ1 ∪ Γ2 :: Γ :: CtxtUnion {{ tex [[Γ1]] \cup [[Γ2]] }}
by

fun
   SC1 & SC2 :: SC :: SCM {{ tex [[SC1]] ~ \& ~[[SC2]] }}
by

fun 
  aus1 & aus2 :: aus :: AUMRG {{ tex [[aus1]] ~ \& ~[[aus2]] }}
by

fun dom ( UC )  :: Ξ :: UCDom by
fun dom ( SC )  :: Ξ :: SCDom by
fun dom ( uσ )  :: Ξ :: uSubDom by
fun dom ( aus ) :: Ξ :: ausolDom by
fun dom ( Θ )   :: Ξ :: uCtxtDomXi by

fun | SC | :: UC :: SCFlatten by
