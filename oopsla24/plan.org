* Abstract
* Introduction
** What is the problem?
    - System F is the basis for the types in many languages.
    - The type inference for Impredicative System F is undecidable:
      Examples instantiating ∀-s.
    - Existential Types are useful, but the type inference for ∃ is under-researched.
** What Good in Solving it?
    - Fundamental duality in logic: forall vs exists 
    - Useful for data abstraction, modules/components, coinductive type encodings, etc
    - Reveals new ways of understanding type inference: usual algorithms for forall rely
      on relationship between specialisation and unification which break in the presence
      of exists
    - As a consequence, the algorithms are ad-hoc and sub-optimal (ML?).
      
** Contributions
    *** Type Inference Algorithm
        Local Type Inference Algorithm for impredicative SystemF with existential types
        - No ∃pack/∀inst anywhere but λ and some let-bindings are annotated 
        - Algorithm is fundamentally novel
            - ∃ brakes the standard invariants that justify using unification
            - Mix UNIF and ANTIUNIF
            - Full correctness proof
            - Exploits CBPV to control 
                quantifiers/arities
        - Subtyping permits
    *** Type Inference Framework
        We discuss the design alternatives
        that allow us to apply the same 
        general scheme of the algorithm 
        to different type systems. 
        - Our work gives a deeper understanding on the inference for impredicative ∃
        - The algorithm as it presented here, cannot be used in practice without modifications.
* Overview
    ** Informal Explanation of our approach
        - subtyping is the driver of the inference: examples
        - Where does the complexity come from?: ∀ and ∃ rules (in a simplified way)
    ** Examples: 
        with syntax explained informally, but reasonably close to the real level of annotations
    ** Introduce the language
        - ±-stratification of the language
        - Language of Types
        - Language of Terms
    ** Examples, Key Ideas
        - System = Declarative + Algorithmic Counterparts 
        *** Types
            - Non-trivial equivalence
            - Type normalization 
            - Algorithmic Variables => Constraints
            - Merging constraints requires Unification.
            - Merging constraints require Least Upper Bound, 
                which is is non-trivial: Anti-Unification
        *** Terms
            - Interface to Subtyping: Annotations, Type applications. 
            - Inference in let bindings: uniqueness
* Declarative System
    ** Subtyping 
        - Explain ∀/∃ Rules
        - Explain substitution specification notation 
        - Explain ↑/↓ Rules
    ** Typing
        - explain the meaning 
        - Variable Context Φ
        - All the rules are inferring
        - up-to-equivalence class
        - Non-Algorithmic rules: ∀-app
        - unpack: requires normalization, checks the wf of the resulting types
        - applicative lets
        - - both invoke application typing
        - - unannotated let: checks uniqueness
        - - annotated let: requires equivalence of the types, which can be relaxed (see extensions)
        - application typing:
        - - non-algorithmic ∀-inf rule
        - where subtyping is invoked: annotations, application typing. 
    ** Properties
        - Variables do not have proper subtypes and supertypes
        - Free Variable propagation: N ≤ M => FV(N) ⊆ FV(M)
        - Characterization of equivalence: variable ordering is sufficient 
        - Characterization of Supertypes
        - Subtyping is Reflexive and Transitive, and is preserved by substitution
        - Subtyping forms a partial order, and positive subtyping forms a semi-lattice
            (with the least-common-supertype operation)
        - However, greatest common negative subtype is not defined (examples?),
            and thus, the subtyping algorithm cannot be simply reduced to meet/join.
* The Algorithm
    [Goal: people can implement it]
    ** Overview
        - Justify Adding α̂± 
        - algorithmic type contexts Ξ and environment Θ
        - Describe how wf, nf,... are changed
        - Constraints -- important part of the algorithm
        - Dependency Graph
    ** Subtyping algorithm
        - fig
        - it takes ... and returns constraint
        - explain the rules
        - - ↑/↓ invoke unification up-to-equivalence, 
            which is implemented by unification of the normal forms up-to-equality.
        - - → makes two recursive calls, and thus, it merges the resulting constraints
        - - ∀/∃ introduce new variables as discussed
        - - the base case calls the upgrade
    ** Unification
    ** Constraint Merge
    ** Upgrade and LUB 
    ** Anti-Unification
    ** Inference
        - Overview (Dependency Graph)
        *** The Inference Algorithm
        *** Constraint Singularity
* Correctness of the Algorithm 
* Extensions and Modifications
    ** Elementary Type Theory
    ** Explicit type application
    ** Bounded quantifiers
    ** Bidirectionalization 
    ** Relaxing ↑
* Related Work
    ** Local Type Inference
    ** A quick look at impredicativity
    ** Existential Crisis Resolved
* Conclusion
