\subsection{Translation to \fexists}

The language of \fexists is different from standard \systemf:
every term and type has either positive or negative polarity.
The type variables are annotated with their polarities
(e.g. $[[α⁺]]$ or $[[β⁻]]$), and the types can change polarity
via the shift operators $[[↑]]$ (positive to negative) and
$[[↓]]$ (negative to positive).

To establish a correspondence between \fexists and standard unpolarized systems,
we present a translation between \fexists and \systemf. The translation of
\systemf to \fexists is given in \cref{fig:translation}.

\begin{figure}
  \begin{equation*}
  \begin{aligned}
    [[|↓iN|]] &= [[|iN|]] \\
    [[|↑iP|]] &= [[|iP|]] \\
  \end{aligned}
  \qquad
  \begin{aligned}
    [[|α±|]] &= [[a]] \\
    [[|iP → iN|]] &= [[|iP| → |iN|]] \\
  \end{aligned}
  \qquad
  \begin{aligned}
    [[|∀α⁺.iN|]] &= [[∀α.|iN|]] \\
    [[|∃α⁻.iP|]] &= [[∃α.|iP|]] \\
  \end{aligned}
  \end{equation*}
  \caption{Type depolarization}
  \label{fig:depolarization}
\end{figure}

The translation from \systemf to \fexists can be done in two canonical ways
depending on the desired polarity. The polarity will also determine the 
execution strategy \ilyam{how?}.
Moreover, the translation procedure depends on the \emph{polarity} of the
free type variables. Thus, the translation functions 
$[[-| fT |-Γ]]$ and $[[+| fT |+Γ]]$ are indexed by a context $[[Γ]]$, 
containing either $[[α⁺]]$ or $[[α⁻]]$ for each variable $[[α]]$ free in $[[fT]]$.

\begin{figure}
  \begin{equation*}
  \begin{aligned}
    [[-| a |-Γ]] &= [[α⁻]]  \text{,~if $[[α⁻ ∊ Γ]]$}\\
    [[-| a |-Γ]] &= [[↑α⁺]] \text{,~if $[[α⁺ ∊ Γ]]$}\\
    [[-| fA → fB |-Γ]] &= [[ +|fA|+Γ → -|fB|-Γ  ]] \\
    [[-| ∀α.fT |-Γ]] &= [[ ∀α⁺.-|fT|-Γ,α⁺ ]] \\
    [[-| ∃α.fT |-Γ]] &= [[ ↑ ∃α⁻.+|fT|+Γ,α⁻ ]] \\
  \end{aligned}
  \qquad
  \begin{aligned}
    [[+| a |+Γ]] &= [[α⁺]]  \text{,~if $[[α⁺ ∊ Γ]]$}\\
    [[+| a |+Γ]] &= [[↓α⁻]] \text{,~if $[[α⁻ ∊ Γ]]$}\\
    [[+| fA → fB |+Γ]] &= [[ ↓ +|fA|+Γ → -|fB|-Γ  ]] \\
    [[+| ∀α.fT |+Γ]] &= [[ ↓∀α⁺.-|fT|-Γ,α⁺ ]] \\
    [[+| ∃α.fT |+Γ]] &= [[ ∃α⁻.+|fT|+Γ,α⁻ ]] \\
  \end{aligned}
  \end{equation*}
  \caption{Type polarization}
  \label{fig:polarization}
\end{figure}



\subsection{What types do we infer?}

Suppose that
we have the following variables in context $[[Φ]]$:

\begin{align*}
  [[map]] &: [[↓∀α⁺.∀β⁺.↓(α⁺ → ↑β⁺) → List α⁺ → ↑List β⁺]] \\
  [[len]] &: [[↓∀α⁺.List α⁺ → ↑Int]] \\
  [[choose]] &: [[↓∀α⁺.α⁺ → α⁺ → ↑α⁺]] \\
  [[id]] &: [[↓∀α⁺.α⁺ → ↑α⁺]] \\
  [[auto]] &: [[↓(∀α⁺.α⁺ → ↑α⁺) → (∀α⁺.α⁺ → ↑α⁺)]]\\
\end{align*}

Then 

\begin{align*}
  &[[· ; Φ ⊢ [two, three, nine] : List Int]]\\
  &[[· ; Φ ⊢ let x = map(id, [two, three, nine]); return x : ↑ List Int]] \ilyam{(no)}\\
\end{align*}



\subsection{The Language of Types}

The types of \fexists are given in \cref{fig:declarative-types}.
They are stratified into two syntactic 
categories (polarities): positive and negative,  
similarly to the \CBPV system \cite{levy2006:cbpv}.
The negative types represent computations, and the positive types represent values:
\begin{itemize}
\item [$-$] $[[na]]$ is a negative type variable, which can be taken from a context or introduced by $[[∃]]$.
\item [$-$] a function $[[iP → iN]]$ takes a value as input and returns a computation; 
\item [$-$] a polymorphic abstraction $[[∀pas.iN]]$ quantifies a computation over
  a list of positive type variables 
  $[[pas]]$. The polarities are chosen to follow the definition of functions.
\item [$-$] a shift $[[↑iP]]$ allows a value to be used as a computation, 
  which at the term level corresponds to a pure computation $[[return v]]$.
\item [$+$] $[[pa]]$ is a positive type variable, taken from a context or introduced by $[[∀]]$.
\item [$+$] $[[∃nas.iP]]$, symmetrically to $[[∀]]$, 
  binds negative variables in a positive type $[[iP]]$. 
\item [$+$] a shift $[[↓iN]]$, symmetrically to the up-shift, 
  thunks a computation, which at the term level corresponds to $[[ {c} ]]$.
\end{itemize}

\begin{figure}[h]
  \begin{multicols}{2}
    \ottgrammartabular{
      \ottiN\ottinterrule
    }\\
    \ottgrammartabular{
      \ottiP\ottinterrule
    }
    \columnbreak
  \end{multicols}
  \caption{Declarative Types of \fexists}
  \label{fig:declarative-types}
\end{figure}

\paragraph{Definitional Equalities}
For simplicity, we assume that alpha-equivalent terms are equal.
This way, we assume that substitutions do not capture bound variables.
Besides, we equate
$[[∀pas.∀pbs.iN]]$ with $[[∀pas,pbs.iN]]$, 
as well as $[[∃nas.∃nbs.iP]]$ with $[[∃nas,nbs.iP]]$,
and lift these equations transitively and congruently 
to the whole system.

\paragraph{Type Context and Type Well-formedness}

In the construction of \fexists, a type context (denoted as $[[Γ]]$) is
represented as a \emph{set} of positive and negative type variables and it is used to
assert the well-formedness of types. The well-formedness of a type is denoted as
$[[Γ ⊢ iP]]$ and $[[Γ ⊢ iN]]$ and it asserts that all type variables are either
bound by a quantifier ($[[∀]]$ and $[[∃]]$) or declared in the context $[[Γ]]$.
The well-formedness checking is an \emph{algorithmic} procedure. As commonly
done, we represent it as a system of inference rules, that correspond to a
recursive algorithm taking the context and the type as input. 

\subsection{The Language of Terms}

In \cref{fig:declarative-terms}, we define the language of terms of 
\fexists. The language combines \systemf with the \CBPV approach.

\begin{itemize}
    \item [$+$] $[[x]]$ denotes a term variable.
      Following the \CBPV stratification, we only have \emph{positive} (value)
      term variables;
    \item [$+$] $[[{c}]]$ is a value corresponding to a thunked 
        or suspended computation;
    \item [$\pm$] $[[(c : iN)]]$ and $[[(v : iP)]]$ allow one to annotate 
        positive and negative terms;
    \item [$-$] $[[return v]]$ is a pure computation, returning a value;
    \item [$-$] $[[λ x : iP . c]]$ and $[[Λ pa . c]]$
        are standard lambda abstractions. Notice that we require
        the type annotation for the argument of $[[λ]]$;
    \item [$-$] $[[ let x = v ; c]]$ is a standard let, binding
        a value $[[v]]$ to a variable $[[x]]$ in a computation $[[c]]$;
    \item [$-$] Applicative let forms $[[let x : iP = v ( args ) ; c]]$ and
        $[[let x = v ( args ) ; c]]$ operate similarly to 
        the bind of a monad: they take a suspended computation $[[v]]$,
        apply it to a list of arguments, bind the result 
        (which is expected to be pure) to a variable $[[x]]$,
        and continue with a computation $[[c]]$.
        If the resulting type of the application is unique, 
        one can omit the type annotation, as in the second form:
        it will be inferred by the algorithm;
    \item [$-$] $[[let∃ ( nas , x ) = v ; c]]$
        is the standard unpack of an existential type:
        expecting $[[v]]$ to be an existential type,
        it binds the packed negative types to a list of 
        variables $[[nas]]$, binds the body of the existential
        to $[[x]]$, and continues with a computation $[[c]]$.
\end{itemize}

\paragraph{Missing constructors}
Notice that the language does not have first-class applications: 
their role is played by the applicative let forms, binding 
the result of a \emph{fully applied} function to a variable.
Also notice that the language does not have a type application (i.e. the eliminator of $[[∀]]$) and dually, it does not have \pack (i.e. the constructor of $[[∃]]$).
This is because the instantiation of polymorphic and existential types is inferred by the algorithm. 
In \cref{sec:extensions}, we discuss the way to modify the system to introduce \emph{explicit} type applications.


\begin{figure}[h]
  \begin{multicols}{2}
    \ottgrammartabular{
      \ottc\ottinterrule
    }

    \ottgrammartabular{
      \ottv\ottinterrule
    }
  \end{multicols}
  \caption{Declarative Terms of \fexists}
  \label{fig:declarative-terms}
\end{figure}

\subsection{The key ideas of the algorithm}

