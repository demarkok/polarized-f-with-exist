% Imprediicative
% CBPV, monadic control
% Local Inference
% Two ways to translate

The language of \fexists is different from standard \systemf:
every term and type has either positive or negative polarity.
The type variables are annotated with their polarities
(e.g. $[[α⁺]]$ or $[[β⁻]]$), and the types can change polarity
via the shift operators $[[↑]]$ (positive to negative) and
$[[↓]]$ (negative to positive).

Positive expressions correspond to values in the \CBPV system
\cite{levy2006:cbpv}, and negative expressions correspond to computations.
The difference between the computations and values is intuitively described 
in the slogan of \CBPV: ``a value is, a computation does''. 
In particular, an argument of a function is always a value (\ie positive), 
and the resulting type, as well as the function itself, 
is a computation (\ie negative).

\subsection{Examples}

In general, any term and type of \systemf can be embedded into \fexists.
This embedding---polarization---will be covered in more details in \cref{sec:rel-to-systemf}.
Now, we discuss a number of examples of standard \systemf terms and types
and their polarization in \fexists.

\begin{figure}[h]
  \begin{align*}
    [[map]] &: [[↓∀α⁺.∀β⁺.↓(α⁺ → ↑β⁺) → List α⁺ → ↑List β⁺]] \\
    [[len]] &: [[↓∀α⁺.List α⁺ → ↑Int]] \\
    [[choose]] &: [[↓∀α⁺.α⁺ → α⁺ → ↑α⁺]] \\
    [[id]] &: [[↓∀α⁺.α⁺ → ↑α⁺]] \\
    [[auto]] &: [[↓(∀α⁺.α⁺ → ↑α⁺) → (∀α⁺.α⁺ → ↑α⁺)]]\\
    [[autoP]] &: [[↓(∀α⁺.α⁺ → ↑α⁺) → (∀α⁺.α⁺ → ↑α⁺)]]\\
  \end{align*}
  \caption{Polarization of standard \systemf terms}
  \label{fig:polarization-examples}
\end{figure}

Let us assume that $[[Φ]]$ is a context containing the terms from \cref{fig:polarization-examples}.
Then the following types are inferrable in \fexists:

\begin{align*}
  % &[[· ; Φ ⊢ [two, three, nine] : List Int]]\\
  &[[· ; Φ, x1:↓(↓iN → iN), x2:↓(↓iM → iM) ⊢ let x = choose (x1, x2); return x : ↑ ∃γ⁻.↓(↓γ⁻ → γ⁻)]]\\
  &[[· ; Φ ⊢ let x = choose (id, auto); return x : ↑ ∃γ⁻.↓γ⁻]]\\
  &[[· ; Φ ⊢ let x = choose (id, autoP); return x : ↑ ∃γ⁻.↓γ⁻]]\\
\end{align*}

The focus of our system is the \emph{local} type inference \cite{pierce2000:local},
which has certain limitations.
In particular, if an argument of a function is polymorphic,
its polymorphic variables are not instantiated by the inference algorithm. 
For example, one would expect the following to be inferrable:
$[[· ; Φ ⊢ let x = map(id, [two, three, nine]); return x : ↑ List Int]]$.
However, to infer this, the $[[id]]$ must be instantiated to $[[Int → ↑Int]]$, 
which requires the information to be propagated from the neighboring branch 
of the syntax tree ($[[ [two, three, nine] ]]$), \ie bypass the locality. 

However, the polymorphic arguments of the function are instantiated, 
and thus, the annotated version of the same term infers the type successfully:
$[[· ; Φ ⊢ let x = map((id : ↓(Int → ↑Int)), [two, three, nine]); return x : ↑ List Int]]$.


\subsection{The Language of Types}

The types of \fexists are given in \cref{fig:declarative-types}.
They are stratified into two syntactic 
categories (polarities): positive and negative,  
similar to the values and computations in the \CBPV system \cite{levy2006:cbpv}.
\begin{itemize}
\item [$-$] $[[na]]$ is a negative type variable, which can be taken from a context or introduced by $[[∃]]$.
\item [$-$] a function $[[iP → iN]]$ takes a value as input and returns a computation; 
\item [$-$] a polymorphic abstraction $[[∀pas.iN]]$ quantifies a computation over
  a list of positive type variables 
  $[[pas]]$. The polarities are chosen to follow the definition of functions.
\item [$-$] a shift $[[↑iP]]$ allows a value to be used as a computation, 
  which at the term level corresponds to a pure computation $[[return v]]$.
\item [$+$] $[[pa]]$ is a positive type variable, taken from a context or introduced by $[[∀]]$.
\item [$+$] $[[∃nas.iP]]$, symmetrically to $[[∀]]$, 
  binds negative variables in a positive type $[[iP]]$. 
\item [$+$] a shift $[[↓iN]]$, symmetrically to the up-shift, 
  thunks a computation, which at the term level corresponds to $[[ {c} ]]$.
\end{itemize}

\begin{figure}[h]
  \begin{multicols}{2}
    \ottgrammartabular{
      \ottiN\ottinterrule
    }\\
    \ottgrammartabular{
      \ottiP\ottinterrule
    }
    \columnbreak
  \end{multicols}
  \caption{Declarative Types of \fexists}
  \label{fig:declarative-types}
\end{figure}

\paragraph{Definitional Equalities}
For simplicity, we assume that alpha-equivalent terms are equal.
This way, we assume that substitutions do not capture bound variables.
Besides, we equate
$[[∀pas.∀pbs.iN]]$ with $[[∀pas,pbs.iN]]$, 
as well as $[[∃nas.∃nbs.iP]]$ with $[[∃nas,nbs.iP]]$,
and lift these equations transitively and congruently 
to the whole system.

\paragraph{Type Context and Type Well-formedness}

In the construction of \fexists, a type context (denoted as $[[Γ]]$) is
represented as a \emph{set} of positive and negative type variables and it is used to
assert the well-formedness of types. The well-formedness of a type is denoted as
$[[Γ ⊢ iP]]$ and $[[Γ ⊢ iN]]$ and it asserts that all type variables are either
bound by a quantifier ($[[∀]]$ and $[[∃]]$) or declared in the context $[[Γ]]$.
The well-formedness checking is an \emph{algorithmic} procedure. As commonly
done, we represent it as a system of inference rules, that correspond to a
recursive algorithm taking the context and the type as input. 

\subsection{The Language of Terms}

In \cref{fig:declarative-terms}, we define the language of terms of 
\fexists. The language combines \systemf with the \CBPV approach.

\begin{itemize}
    \item [$+$] $[[x]]$ denotes a term variable.
      Following the \CBPV stratification, we only have \emph{positive} (value)
      term variables;
    \item [$+$] $[[{c}]]$ is a value corresponding to a thunked 
        or suspended computation;
    \item [$\pm$] $[[(c : iN)]]$ and $[[(v : iP)]]$ allow one to annotate 
        positive and negative terms;
    \item [$-$] $[[return v]]$ is a pure computation, returning a value;
    \item [$-$] $[[λ x : iP . c]]$ and $[[Λ pa . c]]$
        are standard lambda abstractions. Notice that we require
        the type annotation for the argument of $[[λ]]$;
    \item [$-$] $[[ let x = v ; c]]$ is a standard let, binding
        a value $[[v]]$ to a variable $[[x]]$ in a computation $[[c]]$;
    \item [$-$] Applicative let forms $[[let x : iP = v ( args ) ; c]]$ and
        $[[let x = v ( args ) ; c]]$ operate similarly to 
        the bind of a monad: they take a suspended computation $[[v]]$,
        apply it to a list of arguments, bind the result 
        (which is expected to be pure) to a variable $[[x]]$,
        and continue with a computation $[[c]]$.
        If the resulting type of the application is unique, 
        one can omit the type annotation, as in the second form:
        it will be inferred by the algorithm;
    \item [$-$] $[[let∃ ( nas , x ) = v ; c]]$
        is the standard unpack of an existential type:
        expecting $[[v]]$ to be an existential type,
        it binds the packed negative types to a list of 
        variables $[[nas]]$, binds the body of the existential
        to $[[x]]$, and continues with a computation $[[c]]$.
\end{itemize}

\paragraph{Missing constructors}
Notice that the language does not have first-class applications: 
their role is played by the applicative let forms, binding 
the result of a \emph{fully applied} function to a variable.
Also notice that the language does not have a type application (i.e. the eliminator of $[[∀]]$) and dually, it does not have \pack (i.e. the constructor of $[[∃]]$).
This is because the instantiation of polymorphic and existential types is inferred by the algorithm. 
In \cref{sec:extensions}, we discuss the way to modify the system to introduce \emph{explicit} type applications.


\begin{figure}[h]
  \begin{multicols}{2}
    \ottgrammartabular{
      \ottc\ottinterrule
    }

    \ottgrammartabular{
      \ottv\ottinterrule
    }
  \end{multicols}
  \caption{Declarative Terms of \fexists}
  \label{fig:declarative-terms}
\end{figure}

\subsection{The key ideas of the algorithm}

The inference algorithm for \fexists is \emph{local}: it has a limited scope of
the inference information and does not propagate it between far-apart branches
of the syntax tree. Nevertheless, many difficulties appear in the inference of
polymorphic and existential types. Next, we discuss the most challenging of
these difficulties and how they are addressed in the algorithm.

\paragraph{Subtyping} One of the hardest parts of the inference is subtyping,
because this is where the polymorphic instantiation happens. In particular, it
is the subtyping relation that allows us to use the polymorphic terms in the
context where their concrete instantiations are expected: 
$[[Γ ⊢ ∀α⁺.↑α⁺ ≤ ↑Int]]$.

We are able to concentrate most of the difficulty in the subtyping relation 
and then use the polarization to make it decidable. 

\paragraph{Impredicativity}
Impredicativity is another difficulty. Even with forall, the natural subtyping is undecidable. We have to find the restrictions that make it decidable. Unification allows us to solve equality constraints, and the LUB has to be solved with anti-unification. We have to design the system carefully to maintain decidability.

\paragraph{Least Upper Bound}
Now the LUB (Least Upper Bound) is not necessarily the syntactic equality. Examples, types don't have a LUB. How do we decide? The answer is anti-unification, which we explain at a high level. Now we have both forall and exists, and mixing unification and anti-unification.

